"""
Tip Extraction Logic for LLM Coaches
===================================

Extracts actionable tips from natural language coaching outputs 
generated by lightweight and advanced LLM coaches.
"""

import re
from typing import List, Dict, Any

def extract_tips_from_llm_response(llm_response: Dict[str, Any]) -> List[str]:
    """
    Extract top 3 actionable tips from LLM coaching response.
    
    Args:
        llm_response: Full response from LLM coach containing tips, analysis, etc.
        
    Returns:
        List of 3 extracted tips
    """
    
    extracted_tips = []
    
    # 1. Look for tips in the 'tips' field first
    if 'tips' in llm_response and isinstance(llm_response['tips'], list):
        for tip in llm_response['tips']:
            if isinstance(tip, str) and len(tip.strip()) > 10:
                extracted_tips.append(clean_tip_text(tip.strip()))
    
    # 2. Look for tips in educational_content
    if len(extracted_tips) < 3 and 'educational_content' in llm_response:
        educational = llm_response['educational_content']
        if isinstance(educational, dict):
            # Check various fields in educational content
            for field in ['strategy_tips', 'recommendations', 'advice', 'suggestions']:
                if field in educational and isinstance(educational[field], (list, str)):
                    tips = extract_tips_from_text(educational[field])
                    extracted_tips.extend(tips)
                    if len(extracted_tips) >= 3:
                        break
    
    # 3. Look for tips in behavioral_analysis
    if len(extracted_tips) < 3 and 'behavioral_analysis' in llm_response:
        behavioral = llm_response['behavioral_analysis']
        if isinstance(behavioral, dict):
            for field in ['recommendations', 'insights', 'strategy']:
                if field in behavioral and isinstance(behavioral[field], (list, str)):
                    tips = extract_tips_from_text(behavioral[field])
                    extracted_tips.extend(tips)
                    if len(extracted_tips) >= 3:
                        break
    
    # 4. Look for tips in any string fields containing advice patterns
    if len(extracted_tips) < 3:
        for key, value in llm_response.items():
            if isinstance(value, str) and len(value) > 50:
                tips = extract_tips_from_text(value)
                extracted_tips.extend(tips)
                if len(extracted_tips) >= 3:
                    break
    
    # 5. Fallback: Generate tips from insights if available
    if len(extracted_tips) < 3 and 'insights' in llm_response:
        insights = llm_response['insights']
        if isinstance(insights, dict):
            for key, value in insights.items():
                if isinstance(value, str) and len(value) > 20:
                    tip = convert_insight_to_tip(key, value)
                    if tip:
                        extracted_tips.append(tip)
                        if len(extracted_tips) >= 3:
                            break
    
    # Clean and deduplicate tips
    unique_tips = []
    seen_tips = set()
    
    for tip in extracted_tips:
        clean_tip = clean_tip_text(tip)
        if clean_tip and clean_tip.lower() not in seen_tips and len(clean_tip) > 15:
            unique_tips.append(clean_tip)
            seen_tips.add(clean_tip.lower())
            if len(unique_tips) >= 3:
                break
    
    # Ensure we have exactly 3 tips
    while len(unique_tips) < 3:
        unique_tips.append(generate_fallback_tip(len(unique_tips)))
    
    return unique_tips[:3]

def extract_tips_from_text(text_data) -> List[str]:
    """Extract actionable tips from text using pattern matching."""
    
    tips = []
    
    if isinstance(text_data, list):
        # If it's a list, process each item
        for item in text_data:
            if isinstance(item, str):
                tips.extend(extract_tips_from_text(item))
    elif isinstance(text_data, str):
        # Pattern matching for tip-like sentences
        
        # Look for sentences starting with action words
        action_patterns = [
            r'(?:Try|Use|Play|Focus|Watch|Look|Consider|Switch|Counter|Avoid|Target|Exploit)\s+[^.!?]+[.!?]',
            r'(?:You should|I recommend|My advice is|Strategy:|Tip:)\s+[^.!?]+[.!?]',
            r'(?:Based on|Given that|Since)\s+[^,]+,\s*(?:try|use|play|focus|consider)\s+[^.!?]+[.!?]',
        ]
        
        for pattern in action_patterns:
            matches = re.findall(pattern, text_data, re.IGNORECASE)
            for match in matches:
                clean_match = clean_tip_text(match)
                if clean_match and len(clean_match) > 15:
                    tips.append(clean_match)
        
        # Look for numbered/bulleted lists
        list_patterns = [
            r'[•\-\*]\s*([^•\-\*\n]+)',
            r'\d+[\.\)]\s*([^\d\n]+)',
        ]
        
        for pattern in list_patterns:
            matches = re.findall(pattern, text_data)
            for match in matches:
                clean_match = clean_tip_text(match.strip())
                if clean_match and len(clean_match) > 15:
                    tips.append(clean_match)
    
    return tips

def clean_tip_text(tip: str) -> str:
    """Clean and format tip text."""
    
    if not tip:
        return ""
    
    # Remove common prefixes
    prefixes_to_remove = [
        'tip:', 'strategy:', 'advice:', 'recommendation:', 'suggestion:',
        'you should', 'i recommend', 'my advice is', 'try to', 'make sure to'
    ]
    
    tip_lower = tip.lower().strip()
    for prefix in prefixes_to_remove:
        if tip_lower.startswith(prefix):
            tip = tip[len(prefix):].strip()
            break
    
    # Remove markdown formatting
    tip = re.sub(r'\*\*(.*?)\*\*', r'\1', tip)  # Bold
    tip = re.sub(r'\*(.*?)\*', r'\1', tip)      # Italic
    tip = re.sub(r'`(.*?)`', r'\1', tip)        # Code
    
    # Clean up punctuation
    tip = tip.strip(' .,!?-')
    
    # Capitalize first letter
    if tip:
        tip = tip[0].upper() + tip[1:]
    
    # Ensure it ends with proper punctuation
    if tip and tip[-1] not in '.!?':
        tip += '.'
    
    return tip

def convert_insight_to_tip(insight_key: str, insight_value: str) -> str:
    """Convert an insight into an actionable tip."""
    
    insight_to_tip_map = {
        'pattern': {
            'strong': "Exploit their predictable pattern with precise counters",
            'weak': "Stay flexible as their pattern is still forming",
            'none': "Focus on psychological reads since no clear pattern exists"
        },
        'momentum': {
            'favor': "Press your advantage while maintaining focus", 
            'opponent': "Disrupt their momentum with unexpected moves",
            'neutral': "Next few moves are critical - play strategically"
        },
        'strategy': {
            'maintain': "Continue your current approach as it's working",
            'adjust': "Time to evolve your strategy as they've adapted",
            'pivot': "Make a bold strategy change to break their counter"
        }
    }
    
    insight_key = insight_key.lower()
    insight_value = insight_value.lower()
    
    if insight_key in insight_to_tip_map:
        tip_options = insight_to_tip_map[insight_key]
        for keyword, tip in tip_options.items():
            if keyword in insight_value:
                return tip
    
    # Fallback: Convert insight directly
    if 'strong' in insight_value or 'high' in insight_value:
        return f"Leverage the strong {insight_key} signal in your strategy"
    elif 'weak' in insight_value or 'low' in insight_value:
        return f"Be cautious with the weak {insight_key} indication"
    else:
        return f"Consider the {insight_key} factor in your next moves"

def generate_fallback_tip(tip_index: int) -> str:
    """Generate fallback tips when extraction fails."""
    
    fallback_tips = [
        "Stay unpredictable to keep your opponent guessing",
        "Focus on their patterns while hiding your own",
        "Use psychological pressure at critical moments"
    ]
    
    return fallback_tips[min(tip_index, len(fallback_tips) - 1)]

def validate_tip_quality(tips: List[str]) -> List[str]:
    """Validate and improve tip quality."""
    
    improved_tips = []
    
    for tip in tips:
        # Skip very short or generic tips
        if len(tip) < 15 or any(generic in tip.lower() for generic in ['good luck', 'try your best', 'play well']):
            continue
            
        # Ensure tip is actionable (contains action words)
        action_words = ['try', 'use', 'play', 'focus', 'watch', 'look', 'consider', 'switch', 'counter', 'avoid', 'target', 'exploit']
        if not any(word in tip.lower() for word in action_words):
            # Make it more actionable
            tip = f"Try to {tip.lower()}"
            
        improved_tips.append(tip)
    
    return improved_tips
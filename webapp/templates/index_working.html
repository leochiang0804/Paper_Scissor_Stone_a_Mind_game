<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper Scissor Stone ML Game</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 10px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
        }
        .move-btn { 
            padding: 15px 20px; 
            margin: 10px; 
            font-size: 16px; 
            cursor: pointer; 
            border: 2px solid #4CAF50; 
            background: #4CAF50; 
            color: white; 
            border-radius: 8px; 
        }
        .move-btn:hover { 
            background: #45a049; 
        }
        .result { 
            margin: 20px 0; 
            padding: 20px; 
            background: #e8f5e8; 
            border-radius: 8px; 
            border-left: 4px solid #4CAF50; 
        }
        .stats { 
            display: flex; 
            gap: 20px; 
            margin: 20px 0; 
        }
        .stat-card { 
            flex: 1; 
            padding: 15px; 
            background: #fff3e0; 
            border-radius: 8px; 
            text-align: center; 
        }
        .current-strategy { 
            text-align: center; 
            margin: 20px 0; 
            padding: 15px; 
            background: #fff3e0; 
            border-radius: 10px; 
            border-left: 4px solid #ff9800; 
        }
        .controls { 
            text-align: center; 
            margin: 20px 0; 
        }
        select, input { 
            margin: 5px 10px; 
            padding: 5px; 
        }
        .analytics-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
            border-left: 4px solid #1976d2;
        }
        .move-bar {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .move-label {
            width: 80px;
            font-weight: bold;
            text-align: right;
        }
        .bar-container {
            flex: 1;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
        }
        .bar-fill {
            height: 100%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }
        .bar-percentage {
            width: 50px;
            text-align: left;
            font-weight: bold;
        }

        /* Personality Theme Styles */
        .personality-aggressive {
            --personality-color: #ff4444;
            --personality-bg: #fff5f5;
        }

        .personality-defensive {
            --personality-color: #4444ff;
            --personality-bg: #f5f5ff;
        }

        .personality-adaptive {
            --personality-color: #9944ff;
            --personality-bg: #faf5ff;
        }

        .personality-chaotic {
            --personality-color: #ff8844;
            --personality-bg: #fff8f5;
        }

        .personality-copycat {
            --personality-color: #44ff44;
            --personality-bg: #f5fff5;
        }

        /* Advanced Personality Themes */
        .personality-berserker {
            --personality-color: #FF0000;
            --personality-bg: #FFE4E4;
            --accent-color: #FF4500;
        }

        .personality-guardian {
            --personality-color: #0066CC;
            --personality-bg: #E8F4FF;
            --accent-color: #4A90E2;
        }

        .personality-chameleon {
            --personality-color: #9932CC;
            --personality-bg: #F5E6FF;
            --accent-color: #BA55D3;
        }

        .personality-professor {
            --personality-color: #006400;
            --personality-bg: #E8F5E8;
            --accent-color: #228B22;
        }

        .personality-wildcard {
            --personality-color: #FF6347;
            --personality-bg: #FFF8DC;
            --accent-color: #FFD700;
        }

        .personality-mirror {
            --personality-color: #708090;
            --personality-bg: #F0F8FF;
            --accent-color: #87CEEB;
        }

        .personality-aggressive .container,
        .personality-defensive .container,
        .personality-adaptive .container,
        .personality-chaotic .container,
        .personality-copycat .container,
        .personality-berserker .container,
        .personality-guardian .container,
        .personality-chameleon .container,
        .personality-professor .container,
        .personality-wildcard .container,
        .personality-mirror .container {
            border: 2px solid var(--personality-color);
            background: var(--personality-bg);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Paper Scissor Stone ML Game</h1>
        
        <!-- 🎮 ENHANCED REPLAY CONTROLS (New Feature #1) -->
        <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <div style="margin-bottom: 10px; font-weight: 600; color: #495057; font-size: 1.1em;">🎮 Game Controls</div>
            <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                <button onclick="saveCurrentReplay()" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(40,167,69,0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    💾 Save Current Replay
                </button>
                <button onclick="window.open('/replay/dashboard', '_blank')" style="background: linear-gradient(135deg, #007bff 0%, #6610f2 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(0,123,255,0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    🎬 View All Replays
                </button>
                <button onclick="window.open('/developer', '_blank')" style="background: linear-gradient(135deg, #6f42c1 0%, #e83e8c 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(111,66,193,0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    🔧 Developer Console
                </button>
                <button onclick="window.open('/performance', '_blank')" style="background: linear-gradient(135deg, #fd7e14 0%, #dc3545 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(253,126,20,0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    ⚡ Performance Dashboard
                </button>
            </div>
        </div>
        
        <div class="current-strategy">
            <strong>Current Strategy: </strong>
            <span id="current-strategy-text">Analyzing...</span>
        </div>
        
        <div class="controls">
            <label for="difficulty">🎯 AI Difficulty:</label>
            <select id="difficulty" onchange="setDifficulty()">
                <option value="random" {{ 'selected' if default_difficulty == 'random' else '' }}>Random</option>
                <option value="frequency" {{ 'selected' if default_difficulty == 'frequency' else '' }}>Frequency</option>
                <option value="markov" {{ 'selected' if default_difficulty == 'markov' else '' }}>Markov</option>
                <option value="enhanced" {{ 'selected' if default_difficulty == 'enhanced' else '' }}>Enhanced ML</option>
                <option value="lstm" {{ 'selected' if default_difficulty == 'lstm' else '' }}>🧠 LSTM Neural</option>
            </select>
            
            <label for="strategy" style="margin-left: 15px;">⚔️ AI Strategy:</label>
            <select id="strategy" onchange="setStrategy()">
                <option value="balanced">🎯 Balanced</option>
                <option value="to_win">🗡️ To Win (Aggressive)</option>
                <option value="not_to_lose">🛡️ Not to Lose (Defensive)</option>
            </select>
            
            <label for="personality" style="margin-left: 15px;">🤖 AI Personality:</label>
            <select id="personality" onchange="setPersonality()">
                <optgroup label="Basic Personalities">
                    <option value="neutral">😐 Neutral</option>
                    <option value="aggressive">🔥 Aggressive</option>
                    <option value="defensive">🛡️ Defensive</option>
                    <option value="adaptive">🧠 Adaptive</option>
                    <option value="chaotic">🎲 Chaotic</option>
                    <option value="copycat">🐵 Copycat</option>
                </optgroup>
                <optgroup label="Advanced Personalities">
                    <option value="berserker">⚔️ The Berserker</option>
                    <option value="guardian">🛡️ The Guardian</option>
                    <option value="chameleon">🦎 The Chameleon</option>
                    <option value="professor">🔬 The Professor</option>
                    <option value="wildcard">🃏 The Wildcard</option>
                    <option value="mirror">🪞 The Mirror</option>
                </optgroup>
            </select>
            
            <label for="multiplayer" style="margin-left: 15px;">Multiplayer:</label>
            <input type="checkbox" id="multiplayer" onchange="setMultiplayer()">
            
            <div style="margin-top: 15px;">
                <h3>Make your move:</h3>
                <button type="button" id="move-paper" class="move-btn" onclick="submitMove('paper')">
                    Paper (P)
                </button>
                <button type="button" id="move-stone" class="move-btn" onclick="submitMove('stone')">
                    Rock (R)
                </button>
                <button type="button" id="move-scissor" class="move-btn" onclick="submitMove('scissor')">
                    Scissor (S)
                </button>
            </div>
            
            <div style="margin-top: 15px;">
                <button onclick="resetGame()" style="background: #f44336; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-right: 10px;">🔄 Reset Game</button>
                <button onclick="exportAnalytics()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-right: 10px;">📊 Export Data</button>
                <button onclick="showTournamentDashboard()" style="background: #9C27B0; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">🏆 Tournament</button>
            </div>
        </div>
        
        <div id="result" class="result">
            Press buttons or use A, W, D keys to play!
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <h4>Rounds</h4>
                <div id="rounds">{{ round }}</div>
            </div>
            <div class="stat-card">
                <h4>Your Wins</h4>
                <div id="human-wins">{{ stats.human_win }}</div>
            </div>
            <div class="stat-card">
                <h4>Computer Wins</h4>
                <div id="robot-wins">{{ stats.robot_win }}</div>
            </div>
            <div class="stat-card">
                <h4>Ties</h4>
                <div id="ties">{{ stats.tie }}</div>
            </div>
        </div>
        
        <!-- Visual Charts Section -->
        <div style="margin-top: 30px;">
            <h3 style="color: #1976d2;">📊 Visual Analytics</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                    <h4 style="color: #1976d2; margin-top: 0; text-align: center;">Move Distribution</h4>
                    <canvas id="moveDistributionChart" style="max-height: 300px;"></canvas>
                </div>
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                    <h4 style="color: #1976d2; margin-top: 0; text-align: center;">Win Rate Trend</h4>
                    <canvas id="winRateTrendChart" style="max-height: 300px;"></canvas>
                </div>
            </div>
            <div style="margin-top: 20px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <h4 style="color: #1976d2; margin-top: 0; text-align: center;">Strategy Timeline</h4>
                <canvas id="strategyTimelineChart" style="max-height: 250px;"></canvas>
            </div>
            <div style="margin-top: 20px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <h4 style="color: #1976d2; margin-top: 0; text-align: center;">🤖 Model Prediction Tracking</h4>
                <p style="color: #666; font-size: 12px; text-align: center; margin: 5px 0;">Compare human moves vs robot moves vs all model predictions (Paper=2, Rock=1, Scissor=0)</p>
                <canvas id="modelPredictionChart" style="max-height: 300px;"></canvas>
            </div>
            <div style="margin-top: 20px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <h4 style="color: #1976d2; margin-top: 0; text-align: center;">🧠 ML Model Comparison Dashboard</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div>
                        <h5 style="color: #333; margin: 0 0 10px 0;">Model Accuracy Comparison</h5>
                        <canvas id="modelAccuracyChart" style="max-height: 250px;"></canvas>
                    </div>
                    <div>
                        <h5 style="color: #333; margin: 0 0 10px 0;">Prediction Confidence Trends</h5>
                        <canvas id="confidenceTrendChart" style="max-height: 250px;"></canvas>
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    <h5 style="color: #333; margin: 0 0 15px 0;">📊 Model Performance Metrics</h5>
                    <div id="modelMetricsTable" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Model metrics will be populated here -->
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    <h5 style="color: #333; margin: 0 0 10px 0;">🎯 Recommended Strategy</h5>
                    <div id="recommendedStrategy" style="padding: 15px; background: #f5f5f5; border-radius: 8px; font-weight: bold; text-align: center;">
                        Analyzing performance...
                    </div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 30px;">
            <h3>Recent History</h3>
            <p><strong>Your moves:</strong> <span id="recent-human">{{ human_history[-10:]|join(', ') }}</span></p>
            <p><strong>Computer moves:</strong> <span id="recent-robot">{{ robot_history[-10:]|join(', ') }}</span></p>
        </div>
        
        <!-- Coaching Tips Section -->
        <div style="margin-top: 30px;">
            <h3 style="color: #a86e3c;">🎓 AI Coach - Personalized Tips</h3>
            <div style="display: flex; gap: 20px; margin-top: 15px;">
                <div style="flex: 2; background: #fff3e0; border-radius: 10px; padding: 20px; border-left: 4px solid #ff9800;">
                    <h4 style="color: #e65100; margin-top: 0; display: flex; align-items: center; justify-content: space-between;">
                        💡 Your Strategy Tips
                        <button onclick="refreshCoachingTips()" style="padding: 8px 15px; background: #ff9800; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">
                            🔄 Get New Tips
                        </button>
                    </h4>
                    <div id="coaching-tips-list" style="line-height: 1.6;">
                        <p style="color: #666; font-style: italic;">Play a few rounds to get personalized coaching tips!</p>
                    </div>
                </div>
                <div style="flex: 1; background: #e8f5e8; border-radius: 10px; padding: 20px; border-left: 4px solid #4caf50;">
                    <h4 style="color: #2e7d32; margin-top: 0;">🧪 Experiments to Try</h4>
                    <div id="experiments-list" style="line-height: 1.5;">
                        <p style="color: #666; font-style: italic;">Suggested strategies will appear here!</p>
                    </div>
                </div>
            </div>
            <div id="insights-summary" style="margin-top: 15px; padding: 15px; background: #f3e5f5; border-radius: 8px; border-left: 4px solid #9c27b0; display: none;">
                <h4 style="color: #6a1b9a; margin-top: 0;">📊 Pattern Analysis</h4>
                <div id="insights-content" style="font-size: 14px; color: #4a148c;"></div>
            </div>
        </div>
        
        <!-- Advanced Analytics Dashboard -->
        <div style="margin-top: 40px;">
            <h3 style="color: #1976d2;">📊 Advanced Analytics Dashboard</h3>
            
            <!-- Strategy Metrics Cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
                <div class="analytics-card">
                    <h4 style="color: #1976d2; margin: 0 0 10px 0;">🎯 Predictability Score</h4>
                    <div id="predictability-score" style="font-size: 24px; font-weight: bold; color: #1976d2;">--</div>
                    <div id="predictability-status" style="font-size: 12px; color: #666; margin-top: 5px;">Analyzing...</div>
                </div>
                
                <div class="analytics-card">
                    <h4 style="color: #388e3c; margin: 0 0 10px 0;">🏆 Win Rate Trend</h4>
                    <div id="win-rate-trend" style="font-size: 24px; font-weight: bold; color: #388e3c;">--</div>
                    <div id="trend-status" style="font-size: 12px; color: #666; margin-top: 5px;">Recent 10 games</div>
                </div>
                
                <div class="analytics-card">
                    <h4 style="color: #f57c00; margin: 0 0 10px 0;">🔄 Strategy Changes</h4>
                    <div id="strategy-changes-count" style="font-size: 24px; font-weight: bold; color: #f57c00;">--</div>
                    <div id="changes-status" style="font-size: 12px; color: #666; margin-top: 5px;">Adaptability</div>
                </div>
                
                <div class="analytics-card">
                    <h4 style="color: #7b1fa2; margin: 0 0 10px 0;">🎲 Randomness Level</h4>
                    <div id="randomness-level" style="font-size: 24px; font-weight: bold; color: #7b1fa2;">--</div>
                    <div id="randomness-status" style="font-size: 12px; color: #666; margin-top: 5px;">Unpredictability</div>
                </div>
            </div>
            
            <!-- Move Distribution -->
            <div style="margin-top: 30px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <h4 style="color: #1976d2; margin-top: 0;">📈 Move Distribution Analysis</h4>
                <div style="display: flex; gap: 20px; align-items: center;">
                    <div style="flex: 1;">
                        <div id="paper-bar" class="move-bar">
                            <div class="move-label">Paper (P)</div>
                            <div class="bar-container">
                                <div class="bar-fill" id="paper-fill" style="width: 0%; background: #4caf50;"></div>
                            </div>
                            <div class="bar-percentage" id="paper-percent">0%</div>
                        </div>
                        <div id="rock-bar" class="move-bar">
                            <div class="move-label">Rock (R)</div>
                            <div class="bar-container">
                                <div class="bar-fill" id="rock-fill" style="width: 0%; background: #ff9800;"></div>
                            </div>
                            <div class="bar-percentage" id="rock-percent">0%</div>
                        </div>
                        <div id="scissor-bar" class="move-bar">
                            <div class="move-label">Scissor (S)</div>
                            <div class="bar-container">
                                <div class="bar-fill" id="scissor-fill" style="width: 0%; background: #f44336;"></div>
                            </div>
                            <div class="bar-percentage" id="scissor-percent">0%</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Export and Actions -->
            <div style="margin-top: 20px; text-align: center;">
                <button onclick="exportAnalytics('json')" style="padding: 10px 20px; margin: 5px; background: #1976d2; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    📄 Export JSON Report
                </button>
                <button onclick="refreshAnalytics()" style="padding: 10px 20px; margin: 5px; background: #388e3c; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    🔄 Refresh Analytics
                </button>
                <button onclick="showDeveloperMetrics()" style="padding: 10px 20px; margin: 5px; background: #7b1fa2; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    🔧 Developer Metrics
                </button>
            </div>
        </div>
    </div>
    
    <!-- Tournament Modal -->
    <div id="tournamentModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5);">
        <div style="background: white; margin: 5% auto; padding: 20px; width: 80%; max-width: 800px; border-radius: 10px; max-height: 80%; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #1976d2; margin: 0;">🏆 Tournament Dashboard</h2>
                <button onclick="document.getElementById('tournamentModal').style.display='none'" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">✕</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                    <h3 style="margin-top: 0; color: #333;">📊 Tournament Stats</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #1976d2;" id="totalPlayers">0</div>
                            <div style="color: #666;">Total Players</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #1976d2;" id="totalMatches">0</div>
                            <div style="color: #666;">Completed Matches</div>
                        </div>
                    </div>
                </div>
                
                <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                    <h3 style="margin-top: 0; color: #333;">➕ Create Player</h3>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="newPlayerName" placeholder="Enter player name" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <button onclick="createTournamentPlayer()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Create</button>
                    </div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h3 style="color: #333; margin-bottom: 15px;">🏅 Leaderboard</h3>
                    <div id="leaderboard" style="max-height: 300px; overflow-y: auto;">
                        <!-- Leaderboard will be populated here -->
                    </div>
                </div>
                
                <div>
                    <h3 style="color: #333; margin-bottom: 15px;">⚔️ Quick Match</h3>
                    <div style="background: #f9f9f9; padding: 15px; border-radius: 8px;">
                        <p style="color: #666; margin: 0 0 15px 0;">Select two players for a quick match</p>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <input type="text" id="player1Name" placeholder="Player 1 name" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <input type="text" id="player2Name" placeholder="Player 2 name" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        <button onclick="createQuickMatch()" style="background: #FF9800; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; width: 100%;">🎮 Start Match</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        console.log('Main page script loading...');
        
        // Global variables
        let currentDifficulty = '{{ default_difficulty }}';
        let currentStrategy = 'balanced';
        let currentPersonality = 'neutral';
        let currentMultiplayer = false;
        
        // Chart variables
        let moveDistributionChart = null;
        let winRateTrendChart = null;
        let strategyTimelineChart = null;
        let modelPredictionChart = null;
        let modelAccuracyChart = null;
        let confidenceTrendChart = null;
        
        // Initialize charts when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing charts...');
            setTimeout(initializeCharts, 100); // Small delay to ensure DOM is ready
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            console.log('Key pressed:', e.key);
            if (e.key === 'p' || e.key === 'P') submitMove('paper');
            if (e.key === 'r' || e.key === 'R') submitMove('stone'); // Rock = Stone
            if (e.key === 's' || e.key === 'S') submitMove('scissor');
        });
        
        // Game functions
        function submitMove(move) {
            console.log('submitMove called with:', move);
            
            const payload = {
                move: move,
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality,
                multiplayer: currentMultiplayer
            };
            
            if (currentMultiplayer) {
                let move2 = prompt('Player 2, choose paper, scissor, or stone:');
                if (!['paper','scissor','stone'].includes(move2)) {
                    alert('Invalid move for Player 2.');
                    return;
                }
                payload.move2 = move2;
            }
            
            console.log('Sending payload:', payload);
            
            fetch('/play', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            })
            .then(res => {
                console.log('Response status:', res.status);
                return res.json();
            })
            .then(data => {
                console.log('Received data:', data);
                updateUI(data);
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = 
                    '<p style="color: red;">Error: ' + error.message + '</p>';
            });
        }
        
        function updateUI(data) {
            console.log('Updating UI with:', data);
            
            // Safely get the last human move
            const lastHumanMove = data.human_history && data.human_history.length > 0 
                ? data.human_history[data.human_history.length-1] 
                : 'unknown';
            
            // Safely get the robot move
            const robotMove = data.robot_move || 'unknown';
            
            // Safely get the result
            const result = data.result ? String(data.result) : 'unknown';
            
            // Update result
            document.getElementById('result').innerHTML = 
                '<h3>Round ' + (data.round || 0) + ' Results</h3>' +
                '<p>You played: <strong>' + lastHumanMove.toUpperCase() + '</strong></p>' +
                '<p>Computer played: <strong>' + robotMove.toUpperCase() + '</strong></p>' +
                '<p>Result: <strong>' + result.toUpperCase() + '</strong></p>';
            
            // Update stats safely
            const stats = data.stats || {};
            document.getElementById('rounds').textContent = data.round || 0;
            document.getElementById('human-wins').textContent = stats.human_win || 0;
            document.getElementById('robot-wins').textContent = stats.robot_win || 0;
            document.getElementById('ties').textContent = stats.tie || 0;
            
            // Update recent history safely
            const recentHuman = data.human_history ? data.human_history.slice(-10).join(', ') : '';
            const recentRobot = data.robot_history ? data.robot_history.slice(-10).join(', ') : '';
            document.getElementById('recent-human').textContent = recentHuman;
            document.getElementById('recent-robot').textContent = recentRobot;
            
            // Update strategy display
            if (data.current_strategy) {
                const strategy = String(data.current_strategy);
                document.getElementById('current-strategy-text').textContent = 
                    strategy.charAt(0).toUpperCase() + strategy.slice(1);
            }
            
            // Auto-refresh coaching tips every 5 rounds
            if (data.round && data.round > 0 && data.round % 5 === 0) {
                setTimeout(refreshCoachingTips, 500); // Small delay to ensure data is processed
            }
            
            // Update analytics dashboard
            updateAnalyticsDashboard(data);
            
            // Update charts
            updateCharts(data);
        }
        
        // Advanced Analytics Functions
        function updateAnalyticsDashboard(data) {
            if (!data.human_history || data.human_history.length === 0) return;
            
            const history = data.human_history;
            const totalMoves = history.length;
            
            // Calculate move distribution
            const paperCount = history.filter(m => m === 'paper').length;
            const stoneCount = history.filter(m => m === 'stone').length;
            const scissorCount = history.filter(m => m === 'scissor').length;
            
            const paperPercent = ((paperCount / totalMoves) * 100).toFixed(1);
            const stonePercent = ((stoneCount / totalMoves) * 100).toFixed(1);
            const scissorPercent = ((scissorCount / totalMoves) * 100).toFixed(1);
            
            // Update move distribution bars
            document.getElementById('paper-fill').style.width = paperPercent + '%';
            document.getElementById('rock-fill').style.width = stonePercent + '%';
            document.getElementById('scissor-fill').style.width = scissorPercent + '%';
            
            document.getElementById('paper-percent').textContent = paperPercent + '%';
            document.getElementById('rock-percent').textContent = stonePercent + '%';
            document.getElementById('scissor-percent').textContent = scissorPercent + '%';
            
            // Calculate predictability score
            const maxPercent = Math.max(paperPercent, stonePercent, scissorPercent);
            const predictabilityScore = maxPercent;
            document.getElementById('predictability-score').textContent = predictabilityScore + '%';
            
            let predictabilityStatus = 'Highly Unpredictable';
            if (predictabilityScore > 50) predictabilityStatus = 'Somewhat Predictable';
            if (predictabilityScore > 70) predictabilityStatus = 'Very Predictable';
            document.getElementById('predictability-status').textContent = predictabilityStatus;
            
            // Calculate recent win rate trend
            const recentGames = Math.min(10, data.round);
            const recentWins = data.stats ? data.stats.human_win : 0;
            const winRate = data.round > 0 ? ((recentWins / data.round) * 100).toFixed(1) : 0;
            document.getElementById('win-rate-trend').textContent = winRate + '%';
            
            // Calculate randomness level (entropy)
            const p1 = paperCount / totalMoves;
            const p2 = stoneCount / totalMoves;
            const p3 = scissorCount / totalMoves;
            let entropy = 0;
            if (p1 > 0) entropy -= p1 * Math.log2(p1);
            if (p2 > 0) entropy -= p2 * Math.log2(p2);
            if (p3 > 0) entropy -= p3 * Math.log2(p3);
            const randomnessPercent = ((entropy / Math.log2(3)) * 100).toFixed(1);
            document.getElementById('randomness-level').textContent = randomnessPercent + '%';
            
            let randomnessStatus = 'Low Randomness';
            if (randomnessPercent > 60) randomnessStatus = 'Medium Randomness';
            if (randomnessPercent > 80) randomnessStatus = 'High Randomness';
            document.getElementById('randomness-status').textContent = randomnessStatus;
            
            // Strategy changes (placeholder)
            document.getElementById('strategy-changes-count').textContent = Math.floor(data.round / 7) || 0;
        }
        
        function refreshAnalytics() {
            console.log('Refreshing analytics...');
            fetch('/history')
            .then(res => res.json())
            .then(data => {
                console.log('Analytics data received:', data);
                updateAnalyticsDashboard(data);
            })
            .catch(err => console.log('Analytics refresh failed:', err));
        }
        
        function updateStatusDisplay() {
            // Update the game status to show current AI configuration
            const strategyText = {
                'balanced': 'Balanced Strategy',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const personalityText = {
                'neutral': 'Neutral Personality',
                'aggressive': 'Aggressive Personality',
                'defensive': 'Defensive Personality',
                'adaptive': 'Adaptive Personality',
                'chaotic': 'Chaotic Personality',
                'copycat': 'Copycat Personality'
            };
            
            console.log(`AI Config: ${currentDifficulty} + ${strategyText[currentStrategy]} + ${personalityText[currentPersonality]}`);
        }
        
        function applyPersonalityTheme(personality) {
            // Remove existing personality classes
            document.body.classList.remove('personality-aggressive', 'personality-defensive', 'personality-adaptive', 'personality-chaotic', 'personality-copycat');
            
            // Apply new personality theme
            if (personality !== 'neutral') {
                document.body.classList.add(`personality-${personality}`);
            }
            
            // Update UI elements based on personality
            const gameContainer = document.querySelector('.game-container');
            if (gameContainer) {
                const themes = {
                    'neutral': { borderColor: '#ddd', backgroundColor: '#fff' },
                    'aggressive': { borderColor: '#ff4444', backgroundColor: '#fff5f5' },
                    'defensive': { borderColor: '#4444ff', backgroundColor: '#f5f5ff' },
                    'adaptive': { borderColor: '#9944ff', backgroundColor: '#faf5ff' },
                    'chaotic': { borderColor: '#ff8844', backgroundColor: '#fff8f5' },
                    'copycat': { borderColor: '#44ff44', backgroundColor: '#f5fff5' }
                };
                
                const theme = themes[personality] || themes['neutral'];
                gameContainer.style.borderColor = theme.borderColor;
                gameContainer.style.backgroundColor = theme.backgroundColor;
            }
        }
        
        function exportAnalytics(format) {
            console.log('Exporting analytics in format:', format);
            fetch('/analytics/export?format=' + format)
            .then(res => res.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.' + format;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(err => {
                console.log('Export failed, creating manual export:', err);
                // Fallback: create manual JSON export
                const analyticsData = {
                    timestamp: new Date().toISOString(),
                    total_games: parseInt(document.getElementById('rounds').textContent) || 0,
                    predictability_score: document.getElementById('predictability-score').textContent,
                    win_rate: document.getElementById('win-rate-trend').textContent,
                    randomness_level: document.getElementById('randomness-level').textContent,
                    move_distribution: {
                        paper: document.getElementById('paper-percent').textContent,
                        rock: document.getElementById('rock-percent').textContent,
                        scissor: document.getElementById('scissor-percent').textContent
                    }
                };
                const dataStr = JSON.stringify(analyticsData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.json';
                a.click();
            });
        }
        
        function showDeveloperMetrics() {
            const metrics = {
                'Page Load Time': 'Fast',
                'API Response Time': 'Good',
                'JavaScript Errors': 'None',
                'Memory Usage': 'Normal',
                'Network Requests': 'Optimized'
            };
            
            let metricsHtml = '<h4>🔧 Developer Metrics Console</h4>';
            for (const [key, value] of Object.entries(metrics)) {
                metricsHtml += `<p><strong>${key}:</strong> ${value}</p>`;
            }
            metricsHtml += '<p><em>All systems operational</em></p>';
            
            alert('Developer Metrics:\n\n' + Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join('\n'));
        }
        
        // Chart Functions
        function initializeCharts() {
            console.log('Initializing charts...');
            try {
                // Move Distribution Pie Chart
                const moveCtx = document.getElementById('moveDistributionChart');
                if (moveCtx) {
                    moveDistributionChart = new Chart(moveCtx, {
                        type: 'pie',
                        data: {
                            labels: ['Paper (P)', 'Rock (R)', 'Scissor (S)'],
                            datasets: [{
                                data: [0, 0, 0],
                                backgroundColor: ['#4CAF50', '#FF9800', '#F44336'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
                
                // Win Rate Trend Line Chart
                const winCtx = document.getElementById('winRateTrendChart');
                if (winCtx) {
                    winRateTrendChart = new Chart(winCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Win Rate %',
                                data: [],
                                borderColor: '#1976D2',
                                backgroundColor: 'rgba(25, 118, 210, 0.1)',
                                fill: true,
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    ticks: {
                                        callback: function(value) {
                                            return value + '%';
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Strategy Timeline Bar Chart
                const strategyCtx = document.getElementById('strategyTimelineChart');
                if (strategyCtx) {
                    strategyTimelineChart = new Chart(strategyCtx, {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Strategy Usage',
                                data: [],
                                backgroundColor: '#9C27B0',
                                borderColor: '#7B1FA2',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Model Prediction Chart
                const modelCtx = document.getElementById('modelPredictionChart');
                if (modelCtx) {
                    modelPredictionChart = new Chart(modelCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Human Move',
                                    data: [],
                                    borderColor: '#FF6384',
                                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4
                                },
                                {
                                    label: 'Robot Move',
                                    data: [],
                                    borderColor: '#36A2EB',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4
                                },
                                {
                                    label: 'Random Prediction',
                                    data: [],
                                    borderColor: '#FFCE56',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Frequency Prediction',
                                    data: [],
                                    borderColor: '#4BC0C0',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Markov Prediction',
                                    data: [],
                                    borderColor: '#9966FF',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Enhanced Prediction',
                                    data: [],
                                    borderColor: '#FF9F40',
                                    backgroundColor: 'rgba(255, 159, 64, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: {
                                            size: 11
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Move Number'
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Move Type'
                                    },
                                    min: -0.5,
                                    max: 2.5,
                                    ticks: {
                                        stepSize: 1,
                                        callback: function(value) {
                                            if (value === 0) return 'Scissor';
                                            if (value === 1) return 'Rock';
                                            if (value === 2) return 'Paper';
                                            return '';
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Model Accuracy Comparison Chart
                const accuracyCtx = document.getElementById('modelAccuracyChart');
                if (accuracyCtx) {
                    modelAccuracyChart = new Chart(accuracyCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Random', 'Frequency', 'Markov', 'Enhanced', 'LSTM'],
                            datasets: [{
                                label: 'Accuracy (%)',
                                data: [0, 0, 0, 0, 0],
                                backgroundColor: [
                                    'rgba(255, 206, 86, 0.8)',
                                    'rgba(75, 192, 192, 0.8)',
                                    'rgba(153, 102, 255, 0.8)',
                                    'rgba(255, 159, 64, 0.8)',
                                    'rgba(54, 162, 235, 0.8)'
                                ],
                                borderColor: [
                                    'rgba(255, 206, 86, 1)',
                                    'rgba(75, 192, 192, 1)',
                                    'rgba(153, 102, 255, 1)',
                                    'rgba(255, 159, 64, 1)',
                                    'rgba(54, 162, 235, 1)'
                                ],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    title: {
                                        display: true,
                                        text: 'Accuracy (%)'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Confidence Trend Chart
                const confidenceCtx = document.getElementById('confidenceTrendChart');
                if (confidenceCtx) {
                    confidenceTrendChart = new Chart(confidenceCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Random',
                                    data: [],
                                    borderColor: 'rgba(255, 206, 86, 1)',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Frequency',
                                    data: [],
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Markov',
                                    data: [],
                                    borderColor: 'rgba(153, 102, 255, 1)',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Enhanced',
                                    data: [],
                                    borderColor: 'rgba(255, 159, 64, 1)',
                                    backgroundColor: 'rgba(255, 159, 64, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'LSTM',
                                    data: [],
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: { size: 10 }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Move Number'
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    max: 1,
                                    title: {
                                        display: true,
                                        text: 'Confidence'
                                    }
                                }
                            }
                        }
                    });
                }
                
                console.log('Charts initialized successfully');
            } catch (error) {
                console.error('Error initializing charts:', error);
            }
        }
        
        function updateCharts(data) {
            if (!data.human_history || data.human_history.length === 0) return;
            
            try {
                // Update Move Distribution Chart
                if (moveDistributionChart) {
                    const history = data.human_history;
                    const paperCount = history.filter(m => m === 'paper').length;
                    const stoneCount = history.filter(m => m === 'stone').length;
                    const scissorCount = history.filter(m => m === 'scissor').length;
                    
                    moveDistributionChart.data.datasets[0].data = [paperCount, stoneCount, scissorCount];
                    moveDistributionChart.update('none'); // No animation for performance
                }
                
                // Update Win Rate Trend Chart
                if (winRateTrendChart && data.round > 0) {
                    const winRate = data.stats ? ((data.stats.human_win / data.round) * 100).toFixed(1) : 0;
                    
                    // Keep last 20 data points
                    if (winRateTrendChart.data.labels.length >= 20) {
                        winRateTrendChart.data.labels.shift();
                        winRateTrendChart.data.datasets[0].data.shift();
                    }
                    
                    winRateTrendChart.data.labels.push(`R${data.round}`);
                    winRateTrendChart.data.datasets[0].data.push(parseFloat(winRate));
                    winRateTrendChart.update('none');
                }
                
                // Update Strategy Timeline Chart (simplified)
                if (strategyTimelineChart) {
                    const strategies = ['Analyzing', 'Random', 'Frequency', 'Markov', 'Enhanced'];
                    const counts = strategies.map(() => Math.floor(Math.random() * data.round / 5 + 1));
                    
                    strategyTimelineChart.data.labels = strategies;
                    strategyTimelineChart.data.datasets[0].data = counts;
                    strategyTimelineChart.update('none');
                }
                
                // Update Model Prediction Chart
                if (modelPredictionChart && data.human_history && data.robot_history) {
                    const moveToNumber = (move) => {
                        if (move === 'paper') return 2;
                        if (move === 'stone' || move === 'rock') return 1;
                        if (move === 'scissor') return 0;
                        return null;
                    };
                    
                    const humanData = data.human_history.map(moveToNumber);
                    const robotData = data.robot_history.map(moveToNumber);
                    
                    // Use real model predictions from backend
                    const modelPreds = data.model_predictions_history || {};
                    const randomPreds = (modelPreds.random || []).map(moveToNumber);
                    const frequencyPreds = (modelPreds.frequency || []).map(moveToNumber);
                    const markovPreds = (modelPreds.markov || []).map(moveToNumber);
                    const enhancedPreds = (modelPreds.enhanced || []).map(moveToNumber);
                    
                    const labels = Array.from({length: humanData.length}, (_, i) => i + 1);
                    
                    modelPredictionChart.data.labels = labels;
                    modelPredictionChart.data.datasets[0].data = humanData; // Human moves
                    modelPredictionChart.data.datasets[1].data = robotData; // Robot moves
                    modelPredictionChart.data.datasets[2].data = randomPreds; // Random predictions
                    modelPredictionChart.data.datasets[3].data = frequencyPreds; // Frequency predictions
                    modelPredictionChart.data.datasets[4].data = markovPreds; // Markov predictions
                    modelPredictionChart.data.datasets[5].data = enhancedPreds; // Enhanced predictions
                    
                    modelPredictionChart.update('none');
                }
                
                // Update Model Accuracy Chart
                if (modelAccuracyChart && data.accuracy) {
                    const accuracyData = [
                        data.accuracy.random || 0,
                        data.accuracy.frequency || 0, 
                        data.accuracy.markov || 0,
                        data.accuracy.enhanced || 0,
                        data.accuracy.lstm || 0
                    ];
                    modelAccuracyChart.data.datasets[0].data = accuracyData;
                    modelAccuracyChart.update('none');
                }
                
                // Update Confidence Trend Chart
                if (confidenceTrendChart && data.confidence !== undefined) {
                    const moveNum = data.round;
                    
                    // Simulate confidence values for different models (in real implementation, track actual confidence)
                    const confidenceValues = {
                        random: 0.33,
                        frequency: Math.min(0.8, 0.3 + (data.round * 0.02)),
                        markov: Math.min(0.85, 0.4 + (data.round * 0.015)),
                        enhanced: data.confidence || 0.5,
                        lstm: Math.min(0.9, 0.5 + (data.round * 0.01))
                    };
                    
                    if (confidenceTrendChart.data.labels.length > 20) {
                        // Keep only last 20 moves for performance
                        confidenceTrendChart.data.labels.shift();
                        confidenceTrendChart.data.datasets.forEach(dataset => dataset.data.shift());
                    }
                    
                    confidenceTrendChart.data.labels.push(moveNum);
                    confidenceTrendChart.data.datasets[0].data.push(confidenceValues.random);
                    confidenceTrendChart.data.datasets[1].data.push(confidenceValues.frequency);
                    confidenceTrendChart.data.datasets[2].data.push(confidenceValues.markov);
                    confidenceTrendChart.data.datasets[3].data.push(confidenceValues.enhanced);
                    confidenceTrendChart.data.datasets[4].data.push(confidenceValues.lstm);
                    confidenceTrendChart.update('none');
                }
                
                // Update Model Metrics Table
                updateModelMetrics(data);
                
                // Update Recommended Strategy
                updateRecommendedStrategy(data);
                
            } catch (error) {
                console.error('Error updating charts:', error);
            }
        }
        
        // Model Metrics Functions
        function updateModelMetrics(data) {
            const metricsContainer = document.getElementById('modelMetricsTable');
            if (!metricsContainer || !data.accuracy) return;
            
            const models = [
                { name: 'Random', key: 'random', color: '#FFCE56' },
                { name: 'Frequency', key: 'frequency', color: '#4BC0C0' },
                { name: 'Markov', key: 'markov', color: '#9966FF' },
                { name: 'Enhanced', key: 'enhanced', color: '#FF9F40' },
                { name: 'LSTM Neural', key: 'lstm', color: '#36A2EB' }
            ];
            
            metricsContainer.innerHTML = models.map(model => {
                const accuracy = data.accuracy[model.key] || 0;
                const correct = data.correct_predictions?.[model.key] || 0;
                const total = data.total_predictions?.[model.key] || 0;
                
                return `
                    <div style="background: linear-gradient(135deg, ${model.color}20, ${model.color}10); border-left: 4px solid ${model.color}; padding: 15px; border-radius: 8px;">
                        <h6 style="margin: 0 0 8px 0; color: #333; font-weight: bold;">${model.name} Strategy</h6>
                        <div style="font-size: 24px; font-weight: bold; color: ${model.color}; margin-bottom: 5px;">${accuracy.toFixed(1)}%</div>
                        <div style="color: #666; font-size: 12px;">
                            Predictions: ${correct}/${total}<br>
                            Status: ${accuracy > 60 ? '🟢 Excellent' : accuracy > 40 ? '🟡 Good' : '🔴 Needs Improvement'}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateRecommendedStrategy(data) {
            const recommendationEl = document.getElementById('recommendedStrategy');
            if (!recommendationEl || !data.accuracy) return;
            
            const accuracies = data.accuracy;
            const bestModel = Object.keys(accuracies).reduce((best, current) => 
                (accuracies[current] || 0) > (accuracies[best] || 0) ? current : best
            );
            
            const bestAccuracy = accuracies[bestModel] || 0;
            const modelNames = {
                'random': 'Random Strategy',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'enhanced': 'Enhanced ML',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const recommendation = bestAccuracy > 60 ? 
                `🏆 ${modelNames[bestModel]} (${bestAccuracy.toFixed(1)}% accuracy)` :
                `🔄 Continue analyzing patterns (Best: ${modelNames[bestModel]} at ${bestAccuracy.toFixed(1)}%)`;
                
            recommendationEl.innerHTML = `
                <div style="color: ${bestAccuracy > 60 ? '#4CAF50' : '#FF9800'};">
                    ${recommendation}
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    ${data.round < 10 ? 'Play more rounds for better analysis' : 'Pattern analysis complete'}
                </div>
            `;
        }
        
        // Tournament Management Functions
        function showTournamentDashboard() {
            fetch('/tournament')
            .then(res => res.json())
            .then(data => {
                updateTournamentDashboard(data);
                document.getElementById('tournamentModal').style.display = 'block';
            })
            .catch(err => console.error('Error fetching tournament data:', err));
        }
        
        function updateTournamentDashboard(data) {
            // Update leaderboard
            const leaderboardHtml = data.leaderboard.map((player, index) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: ${index < 3 ? '#f0f8ff' : '#f9f9f9'}; margin: 5px 0; border-radius: 5px;">
                    <div>
                        <span style="font-weight: bold; color: ${index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#666'};">
                            #${index + 1}
                        </span>
                        ${player.name}
                    </div>
                    <div style="text-align: right;">
                        <div style="font-weight: bold;">${Math.round(player.elo_rating)}</div>
                        <div style="font-size: 12px; color: #666;">${player.wins}W-${player.losses}L</div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('leaderboard').innerHTML = leaderboardHtml;
            
            // Update stats
            document.getElementById('totalPlayers').textContent = data.total_players;
            document.getElementById('totalMatches').textContent = data.total_matches;
        }
        
        function createTournamentPlayer() {
            const name = document.getElementById('newPlayerName').value.trim();
            if (!name) {
                alert('Please enter a player name');
                return;
            }
            
            fetch('/tournament/player', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({name: name})
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('newPlayerName').value = '';
                    showTournamentDashboard(); // Refresh dashboard
                    alert(`Player "${data.player.name}" created successfully!`);
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(err => {
                console.error('Error creating player:', err);
                alert('Error creating player');
            });
        }
        
        function createQuickMatch() {
            const player1 = document.getElementById('player1Name').value.trim();
            const player2 = document.getElementById('player2Name').value.trim();
            
            if (!player1 || !player2) {
                alert('Please enter both player names');
                return;
            }
            
            fetch('/tournament/match', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    player1_name: player1,
                    player2_name: player2
                })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    alert(`Match created between ${player1} and ${player2}!`);
                    document.getElementById('player1Name').value = '';
                    document.getElementById('player2Name').value = '';
                    // You could redirect to a match interface here
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(err => {
                console.error('Error creating match:', err);
                alert('Error creating match');
            });
        }
        
        // Coaching Functions
        function refreshCoachingTips() {
            console.log('Refreshing coaching tips...');
            fetch('/coaching')
            .then(res => res.json())
            .then(data => {
                console.log('Coaching data received:', data);
                updateCoachingTips(data);
            })
            .catch(err => {
                console.log('Coaching tips unavailable:', err);
                document.getElementById('coaching-tips-list').innerHTML = 
                    '<p style="color: #666; font-style: italic;">Coaching tips will be available after more games.</p>';
            });
        }
        
        function updateCoachingTips(coachingData) {
            const tipsContainer = document.getElementById('coaching-tips-list');
            const experimentsContainer = document.getElementById('experiments-list');
            const insightsContainer = document.getElementById('insights-content');
            const insightsSummary = document.getElementById('insights-summary');
            
            // Update tips
            if (coachingData.coaching_tips && coachingData.coaching_tips.length > 0) {
                const tipsHtml = coachingData.coaching_tips.map((tip, index) => 
                    `<div style="margin-bottom: 12px; padding: 10px; background: rgba(255,152,0,0.1); border-radius: 6px;">
                        <strong>${index + 1}.</strong> ${tip}
                    </div>`
                ).join('');
                tipsContainer.innerHTML = tipsHtml;
            } else {
                tipsContainer.innerHTML = '<p style="color: #666; font-style: italic;">Keep playing to get personalized tips!</p>';
            }
            
            // Update experiments
            if (coachingData.experiments && coachingData.experiments.length > 0) {
                const experimentsHtml = coachingData.experiments.map(exp => 
                    `<div style="margin-bottom: 15px; padding: 12px; background: rgba(76,175,80,0.1); border-radius: 6px;">
                        <strong style="color: #2e7d32;">${exp.name}</strong><br>
                        <small style="color: #388e3c;">${exp.description}</small><br>
                        <em style="font-size: 13px; color: #4caf50;">${exp.strategy}</em>
                    </div>`
                ).join('');
                experimentsContainer.innerHTML = experimentsHtml;
            } else {
                experimentsContainer.innerHTML = '<p style="color: #666; font-style: italic;">Experiment suggestions coming soon!</p>';
            }
            
            // Update insights (optional)
            if (coachingData.insights && Object.keys(coachingData.insights).length > 0) {
                const insights = coachingData.insights;
                let insightsHtml = '';
                
                if (insights.predictability !== undefined) {
                    const predPercent = (insights.predictability * 100).toFixed(1);
                    insightsHtml += `<p><strong>Predictability:</strong> ${predPercent}% - `;
                    insightsHtml += insights.predictability > 0.6 ? 'Too predictable!' : 'Good unpredictability';
                    insightsHtml += '</p>';
                }
                
                if (insights.pattern_type) {
                    insightsHtml += `<p><strong>Pattern Type:</strong> ${insights.pattern_type.replace('_', ' ')}</p>`;
                }
                
                if (insights.recent_performance) {
                    const winRate = (insights.recent_performance.win_rate * 100).toFixed(1);
                    insightsHtml += `<p><strong>Recent Win Rate:</strong> ${winRate}%</p>`;
                }
                
                if (insightsHtml) {
                    insightsContainer.innerHTML = insightsHtml;
                    insightsSummary.style.display = 'block';
                } else {
                    insightsSummary.style.display = 'none';
                }
            } else {
                insightsSummary.style.display = 'none';
            }
        }
        
        function setDifficulty() {
            currentDifficulty = document.getElementById('difficulty').value;
            console.log('Difficulty set to:', currentDifficulty);
        }
        
        function setStrategy() {
            currentStrategy = document.getElementById('strategy').value;
            console.log('Strategy set to:', currentStrategy);
            updateStatusDisplay();
        }
        
        function setPersonality() {
            currentPersonality = document.getElementById('personality').value;
            console.log('Personality set to:', currentPersonality);
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
        }
        
        function setMultiplayer() {
            currentMultiplayer = document.getElementById('multiplayer').checked;
            console.log('Multiplayer set to:', currentMultiplayer);
        }
        
        function resetGame() {
            fetch('/reset', {method: 'POST'})
            .then(res => res.json())
            .then(() => location.reload())
            .catch(error => {
                console.error('Reset error:', error);
                location.reload();
            });
        }
        
        // 🎮 ENHANCED REPLAY FUNCTIONS (New Feature #1)
        function saveCurrentReplay() {
            const name = prompt('Enter a name for this replay:', 'Game Session ' + new Date().toLocaleString());
            if (name) {
                const notes = prompt('Enter any notes (optional):', '');
                const formData = new FormData();
                formData.append('name', name);
                formData.append('notes', notes || '');
                
                fetch('/replay/save', {
                    method: 'POST',
                    body: formData
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        alert(`✅ Replay saved successfully!\nSession ID: ${data.session_id}\nTotal rounds: ${data.total_rounds}`);
                    } else {
                        alert(`❌ Failed to save replay: ${data.message}`);
                    }
                })
                .catch(err => {
                    alert('❌ Error saving replay: ' + err.message);
                });
            }
        }
        
        console.log('Main page script loaded successfully');
    </script>
</body>
</html>
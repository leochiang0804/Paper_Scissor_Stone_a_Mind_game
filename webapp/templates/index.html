<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper Scissor Stone ML Game</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 10px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
        }
        .move-btn { 
            padding: 15px 20px; 
            margin: 10px; 
            font-size: 16px; 
            cursor: pointer; 
            border: 2px solid #4CAF50; 
            background: #4CAF50; 
            color: white; 
            border-radius: 8px; 
        }
        .move-btn:hover { 
            background: #45a049; 
        }
        .result { 
            margin: 20px 0; 
            padding: 20px; 
            background: #e8f5e8; 
            border-radius: 8px; 
            border-left: 4px solid #4CAF50; 
        }
        .stats { 
            display: flex; 
            gap: 20px; 
            margin: 20px 0; 
        }
        .stat-card { 
            flex: 1; 
            padding: 15px; 
            background: #fff3e0; 
            border-radius: 8px; 
            text-align: center; 
        }
        .current-strategy { 
            text-align: center; 
            margin: 20px 0; 
            padding: 15px; 
            background: #fff3e0; 
            border-radius: 10px; 
            border-left: 4px solid #ff9800; 
        }
        .controls { 
            text-align: center; 
            margin: 20px 0; 
        }
        select, input { 
            margin: 5px 10px; 
            padding: 5px; 
        }
        .analytics-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
            border-left: 4px solid #1976d2;
        }
        .move-bar {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .move-label {
            width: 80px;
            font-weight: bold;
            text-align: right;
        }
        .bar-container {
            flex: 1;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
        }
        .bar-fill {
            height: 100%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }
        .bar-percentage {
            width: 50px;
            text-align: left;
            font-weight: bold;
        }

        /* Personality Theme Styles */
        .personality-aggressive {
            --personality-color: #ff4444;
            --personality-bg: #fff5f5;
        }

        .personality-defensive {
            --personality-color: #4444ff;
            --personality-bg: #f5f5ff;
        }

        .personality-adaptive {
            --personality-color: #9944ff;
            --personality-bg: #faf5ff;
        }

        .personality-chaotic {
            --personality-color: #ff8844;
            --personality-bg: #fff8f5;
        }

        .personality-copycat {
            --personality-color: #44ff44;
            --personality-bg: #f5fff5;
        }

        /* Advanced Personality Themes */
        .personality-berserker {
            --personality-color: #FF0000;
            --personality-bg: #FFE4E4;
            --accent-color: #FF4500;
        }

        .personality-guardian {
            --personality-color: #0066CC;
            --personality-bg: #E8F4FF;
            --accent-color: #4A90E2;
        }

        .personality-chameleon {
            --personality-color: #9932CC;
            --personality-bg: #F5E6FF;
            --accent-color: #BA55D3;
        }

        .personality-professor {
            --personality-color: #006400;
            --personality-bg: #E8F5E8;
            --accent-color: #228B22;
        }

        .personality-wildcard {
            --personality-color: #FF6347;
            --personality-bg: #FFF8DC;
            --accent-color: #FFD700;
        }

        .personality-mirror {
            --personality-color: #708090;
            --personality-bg: #F0F8FF;
            --accent-color: #87CEEB;
        }

        .personality-aggressive .container,
        .personality-defensive .container,
        .personality-adaptive .container,
        .personality-chaotic .container,
        .personality-copycat .container,
        .personality-berserker .container,
        .personality-guardian .container,
        .personality-chameleon .container,
        .personality-professor .container,
        .personality-wildcard .container,
        .personality-mirror .container {
            border: 2px solid var(--personality-color);
            background: var(--personality-bg);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Paper Scissor Stone ML Game</h1>
        
        <!-- üéÆ ENHANCED REPLAY CONTROLS (New Feature #1) -->
        <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <div style="margin-bottom: 10px; font-weight: 600; color: #495057; font-size: 1.1em;">üéÆ Game Controls</div>
            <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                <button onclick="saveCurrentReplay()" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(40,167,69,0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    üíæ Save Current Replay
                </button>
                <button onclick="window.open('/replay/dashboard', '_blank')" style="background: linear-gradient(135deg, #007bff 0%, #6610f2 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(0,123,255,0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    üé¨ View All Replays
                </button>
                <button onclick="window.open('/developer', '_blank')" style="background: linear-gradient(135deg, #6f42c1 0%, #e83e8c 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(111,66,193,0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    üîß Developer Console
                </button>
                <button onclick="window.open('/performance', '_blank')" style="background: linear-gradient(135deg, #fd7e14 0%, #dc3545 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(253,126,20,0.3); transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;">
                    ‚ö° Performance Dashboard
                </button>
            </div>
        </div>
        
        <div class="current-strategy">
            <strong>Current Strategy: </strong>
            <span id="current-strategy-text">Analyzing...</span>
        </div>
        
        <div class="controls">
            <label for="difficulty">üéØ AI Difficulty:</label>
            <select id="difficulty" onchange="setDifficulty()">
                <option value="random" {{ 'selected' if default_difficulty == 'random' else '' }}>Random</option>
                <option value="frequency" {{ 'selected' if default_difficulty == 'frequency' else '' }}>Frequency</option>
                <option value="markov" {{ 'selected' if default_difficulty == 'markov' else '' }}>Markov</option>
                <option value="enhanced" {{ 'selected' if default_difficulty == 'enhanced' else '' }}>Enhanced ML</option>
                <option value="lstm" {{ 'selected' if default_difficulty == 'lstm' else '' }}>LSTM Neural</option>
            </select>
            
            <label for="strategy" style="margin-left: 15px;">‚öîÔ∏è AI Strategy:</label>
            <select id="strategy" onchange="setStrategy()">
                <option value="balanced">üéØ Balanced</option>
                <option value="to_win">üó°Ô∏è To Win (Aggressive)</option>
                <option value="not_to_lose">üõ°Ô∏è Not to Lose (Defensive)</option>
            </select>
            
            <label for="personality" style="margin-left: 15px;">ü§ñ AI Personality:</label>
            <select id="personality" onchange="setPersonality()">
                <option value="neutral">üòê Neutral</option>
                <option value="berserker">‚öîÔ∏è The Berserker (Ultra Aggressive)</option>
                <option value="guardian">üõ°Ô∏è The Guardian (Defensive Expert)</option>
                <option value="chameleon">ü¶é The Chameleon (Adaptive)</option>
                <option value="professor">üî¨ The Professor (Analytical)</option>
                <option value="wildcard">üÉè The Wildcard (Unpredictable)</option>
                <option value="mirror">ü™û The Mirror (Mimicking)</option>
            </select>
            
            <!-- DEBUG: Test button -->
            <button onclick="testRobotUpdate()" style="margin-left: 15px; padding: 5px 10px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">üîß Test Update</button>
            
            <!-- Robot Character Display -->
            <div id="robot-character-display" style="margin: 20px 0; padding: 15px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border: 1px solid #dee2e6;">
                <h4 style="text-align: center; margin: 0 0 10px 0; color: #495057;">ü§ñ Your Opponent</h4>
                <div style="display: flex; align-items: center; justify-content: center; gap: 15px;">
                    <!-- Robot Character Avatar -->
                    <div id="robot-avatar" style="position: relative; width: 80px; height: 80px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 40px; transition: all 0.3s ease; background: linear-gradient(135deg, #e9ecef, #f8f9fa); border: 3px solid #dee2e6;">
                        ü§ñ
                        <!-- Strategy Symbol Overlay -->
                        <div id="strategy-symbol" style="position: absolute; bottom: -5px; right: -5px; width: 25px; height: 25px; background: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid #6c757d; box-shadow: 0 1px 3px rgba(0,0,0,0.2);">
                            ‚öîÔ∏è
                        </div>
                    </div>
                    
                    <!-- Robot Info -->
                    <div style="text-align: left;">
                        <div style="font-weight: bold; color: #495057; margin-bottom: 5px;">
                            <span id="robot-name">Standard Robot</span>
                        </div>
                        <div style="font-size: 12px; color: #6c757d; margin-bottom: 2px;">
                            Difficulty: <span id="robot-difficulty">Easy</span>
                        </div>
                        <div style="font-size: 12px; color: #6c757d; margin-bottom: 2px;">
                            Strategy: <span id="robot-strategy">Random</span>
                        </div>
                        <div style="font-size: 12px; color: #6c757d;">
                            Personality: <span id="robot-personality">Balanced</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Robot Conversation Box -->
            <div id="robot-conversation" style="margin: 15px 0; padding: 15px; background: linear-gradient(135deg, #f1f3f4 0%, #e8eaf6 100%); border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-left: 4px solid #5c6bc0; position: relative;">
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <!-- Robot Speech Avatar -->
                    <div id="conversation-avatar" style="width: 40px; height: 40px; border-radius: 50%; background: linear-gradient(135deg, #5c6bc0, #7986cb); display: flex; align-items: center; justify-content: center; font-size: 20px; color: white; flex-shrink: 0;">
                        ü§ñ
                    </div>
                    
                    <!-- Speech Bubble -->
                    <div style="flex: 1;">
                        <div style="background: white; padding: 12px 15px; border-radius: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: relative; margin-bottom: 5px;">
                            <div id="robot-speech" style="font-size: 14px; line-height: 1.4; color: #2c3e50; font-style: italic;">
                                "Ready for battle? Let's see what you've got!"
                            </div>
                            <!-- Speech bubble tail -->
                            <div style="position: absolute; left: -8px; top: 15px; width: 0; height: 0; border-top: 8px solid transparent; border-bottom: 8px solid transparent; border-right: 8px solid white;"></div>
                        </div>
                        <div style="font-size: 11px; color: #6c757d; margin-left: 5px;">
                            <span id="robot-mood">üòé Confident</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Move Display Window -->
            <div id="move-display-window" style="margin: 20px 0; padding: 20px; background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #e9ecef;">
                <h3 style="text-align: center; margin: 0 0 15px 0; color: #495057;">üéÆ Battle Arena</h3>
                <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px;">
                    <!-- Human Move -->
                    <div id="human-move-display" style="text-align: center; padding: 15px; background: rgba(52, 144, 220, 0.1); border-radius: 10px; border: 2px solid transparent; transition: all 0.3s ease; min-width: 120px;">
                        <div style="font-weight: bold; color: #3490dc; margin-bottom: 8px;">You</div>
                        <img id="human-move-img" src="/static/paper.png" alt="Your Move" style="width: 60px; height: 60px; display: none; border-radius: 8px;">
                        <div id="human-move-text" style="margin-top: 8px; font-size: 14px; color: #6c757d;">Choose your move</div>
                    </div>
                    
                    <!-- VS Text -->
                    <div style="font-size: 24px; font-weight: bold; color: #6c757d;">VS</div>
                    
                    <!-- Robot Move -->
                    <div id="robot-move-display" style="text-align: center; padding: 15px; background: rgba(220, 53, 69, 0.1); border-radius: 10px; border: 2px solid transparent; transition: all 0.3s ease; min-width: 120px;">
                        <div style="font-weight: bold; color: #dc3545; margin-bottom: 8px;">Robot</div>
                        <img id="robot-move-img" src="/static/paper.png" alt="Robot Move" style="width: 60px; height: 60px; display: none; border-radius: 8px;">
                        <div id="robot-move-text" style="margin-top: 8px; font-size: 14px; color: #6c757d;">Thinking...</div>
                    </div>
                </div>
                
                <!-- Round Result -->
                <div id="round-result" style="text-align: center; margin-top: 15px; padding: 10px; border-radius: 8px; font-weight: bold; display: none;">
                    Round Result
                </div>
            </div>
            
            <div style="margin-top: 15px;">
                <h3>Make your move:</h3>
                <button type="button" id="move-paper" class="move-btn" onclick="submitMove('paper')">
                    Paper (P)
                </button>
                <button type="button" id="move-stone" class="move-btn" onclick="submitMove('stone')">
                    Rock (R)
                </button>
                <button type="button" id="move-scissor" class="move-btn" onclick="submitMove('scissor')">
                    Scissor (S)
                </button>
            </div>
            
            <div style="margin-top: 15px;">
                <button onclick="resetGame()" style="background: #f44336; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-right: 10px;">üîÑ Reset Game</button>
                <button onclick="exportAnalytics()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-right: 10px;">üìä Export Data</button>
                <button onclick="showTournamentDashboard()" style="background: #9C27B0; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">üèÜ Tournament</button>
            </div>
        </div>
        
        <div id="result" class="result">
            Press buttons or use A, W, D keys to play!
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <h4>Rounds</h4>
                <div id="rounds">{{ round }}</div>
            </div>
            <div class="stat-card">
                <h4>Your Wins</h4>
                <div id="human-wins">{{ stats.human_win }}</div>
            </div>
            <div class="stat-card">
                <h4>Computer Wins</h4>
                <div id="robot-wins">{{ stats.robot_win }}</div>
            </div>
            <div class="stat-card">
                <h4>Ties</h4>
                <div id="ties">{{ stats.tie }}</div>
            </div>
        </div>
        
        <!-- Visual Charts Section -->
        <div style="margin-top: 30px;">
            <h3 style="color: #1976d2;">üìä Visual Analytics</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                    <h4 style="color: #1976d2; margin-top: 0; text-align: center;">Move Distribution</h4>
                    <canvas id="moveDistributionChart" style="max-height: 300px;"></canvas>
                </div>
                <div style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                    <h4 style="color: #1976d2; margin-top: 0; text-align: center;">Win Rate Trend</h4>
                    <canvas id="winRateTrendChart" style="max-height: 300px;"></canvas>
                </div>
            </div>
            <div style="margin-top: 20px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <h4 style="color: #1976d2; margin-top: 0; text-align: center;">Strategy Timeline</h4>
                <canvas id="strategyTimelineChart" style="max-height: 250px;"></canvas>
            </div>
            <div style="margin-top: 20px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <h4 style="color: #1976d2; margin-top: 0; text-align: center;">ü§ñ Model Prediction Tracking</h4>
                <p style="color: #666; font-size: 12px; text-align: center; margin: 5px 0;">Compare human moves vs robot moves vs all model predictions (Paper=2, Rock=1, Scissor=0)</p>
                <canvas id="modelPredictionChart" style="max-height: 300px;"></canvas>
            </div>
            <div style="margin-top: 20px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <h4 style="color: #1976d2; margin-top: 0; text-align: center;">üß† ML Model Comparison Dashboard</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div>
                        <h5 style="color: #333; margin: 0 0 10px 0;">Model Accuracy Comparison</h5>
                        <canvas id="modelAccuracyChart" style="max-height: 250px;"></canvas>
                    </div>
                    <div>
                        <h5 style="color: #333; margin: 0 0 10px 0;">Prediction Confidence Trends</h5>
                        <canvas id="confidenceTrendChart" style="max-height: 250px;"></canvas>
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    <h5 style="color: #333; margin: 0 0 15px 0;">üìä Model Performance Metrics</h5>
                    <div id="modelMetricsTable" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Model metrics will be populated here -->
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    <h5 style="color: #333; margin: 0 0 10px 0;">üéØ Recommended Strategy</h5>
                    <div id="recommendedStrategy" style="padding: 15px; background: #f5f5f5; border-radius: 8px; font-weight: bold; text-align: center;">
                        Analyzing performance...
                    </div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 30px;">
            <h3>Recent History</h3>
            <p><strong>Your moves:</strong> <span id="recent-human">{{ human_history[-10:]|join(', ') }}</span></p>
            <p><strong>Computer moves:</strong> <span id="recent-robot">{{ robot_history[-10:]|join(', ') }}</span></p>
        </div>
        
        <!-- Coaching Tips Section -->
        <div style="margin-top: 30px;">
            <h3 style="color: #a86e3c;">üéì AI Coach - Personalized Tips</h3>
            <div style="display: flex; gap: 20px; margin-top: 15px;">
                <div style="flex: 2; background: #fff3e0; border-radius: 10px; padding: 20px; border-left: 4px solid #ff9800;">
                    <h4 style="color: #e65100; margin-top: 0; display: flex; align-items: center; justify-content: space-between;">
                        üí° Your Strategy Tips
                        <button onclick="refreshCoachingTips()" style="padding: 8px 15px; background: #ff9800; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">
                            üîÑ Get New Tips
                        </button>
                    </h4>
                    <div id="coaching-tips-list" style="line-height: 1.6;">
                        <p style="color: #666; font-style: italic;">Play a few rounds to get personalized coaching tips!</p>
                    </div>
                </div>
                <div style="flex: 1; background: #e8f5e8; border-radius: 10px; padding: 20px; border-left: 4px solid #4caf50;">
                    <h4 style="color: #2e7d32; margin-top: 0;">üß™ Experiments to Try</h4>
                    <div id="experiments-list" style="line-height: 1.5;">
                        <p style="color: #666; font-style: italic;">Suggested strategies will appear here!</p>
                    </div>
                </div>
            </div>
            <div id="insights-summary" style="margin-top: 15px; padding: 15px; background: #f3e5f5; border-radius: 8px; border-left: 4px solid #9c27b0; display: none;">
                <h4 style="color: #6a1b9a; margin-top: 0;">üìä Pattern Analysis</h4>
                <div id="insights-content" style="font-size: 14px; color: #4a148c;"></div>
            </div>
        </div>
        
        <!-- Advanced Analytics Dashboard -->
        <div style="margin-top: 40px;">
            <h3 style="color: #1976d2;">üìä Advanced Analytics Dashboard</h3>
            
            <!-- Strategy Metrics Cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
                <div class="analytics-card">
                    <h4 style="color: #1976d2; margin: 0 0 10px 0;">üéØ Predictability Score</h4>
                    <div id="predictability-score" style="font-size: 24px; font-weight: bold; color: #1976d2;">--</div>
                    <div id="predictability-status" style="font-size: 12px; color: #666; margin-top: 5px;">Analyzing...</div>
                </div>
                
                <div class="analytics-card">
                    <h4 style="color: #388e3c; margin: 0 0 10px 0;">üèÜ Win Rate Trend</h4>
                    <div id="win-rate-trend" style="font-size: 24px; font-weight: bold; color: #388e3c;">--</div>
                    <div id="trend-status" style="font-size: 12px; color: #666; margin-top: 5px;">Recent 10 games</div>
                </div>
                
                <div class="analytics-card">
                    <h4 style="color: #f57c00; margin: 0 0 10px 0;">üîÑ Strategy Changes</h4>
                    <div id="strategy-changes-count" style="font-size: 24px; font-weight: bold; color: #f57c00;">--</div>
                    <div id="changes-status" style="font-size: 12px; color: #666; margin-top: 5px;">Adaptability</div>
                </div>
                
                <div class="analytics-card">
                    <h4 style="color: #7b1fa2; margin: 0 0 10px 0;">üé≤ Randomness Level</h4>
                    <div id="randomness-level" style="font-size: 24px; font-weight: bold; color: #7b1fa2;">--</div>
                    <div id="randomness-status" style="font-size: 12px; color: #666; margin-top: 5px;">Unpredictability</div>
                </div>
            </div>
            
            <!-- Move Distribution -->
            <div style="margin-top: 30px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                <h4 style="color: #1976d2; margin-top: 0;">üìà Move Distribution Analysis</h4>
                <div style="display: flex; gap: 20px; align-items: center;">
                    <div style="flex: 1;">
                        <div id="paper-bar" class="move-bar">
                            <div class="move-label">Paper (P)</div>
                            <div class="bar-container">
                                <div class="bar-fill" id="paper-fill" style="width: 0%; background: #4caf50;"></div>
                            </div>
                            <div class="bar-percentage" id="paper-percent">0%</div>
                        </div>
                        <div id="rock-bar" class="move-bar">
                            <div class="move-label">Rock (R)</div>
                            <div class="bar-container">
                                <div class="bar-fill" id="rock-fill" style="width: 0%; background: #ff9800;"></div>
                            </div>
                            <div class="bar-percentage" id="rock-percent">0%</div>
                        </div>
                        <div id="scissor-bar" class="move-bar">
                            <div class="move-label">Scissor (S)</div>
                            <div class="bar-container">
                                <div class="bar-fill" id="scissor-fill" style="width: 0%; background: #f44336;"></div>
                            </div>
                            <div class="bar-percentage" id="scissor-percent">0%</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Export and Actions -->
            <div style="margin-top: 20px; text-align: center;">
                <button onclick="exportAnalytics('json')" style="padding: 10px 20px; margin: 5px; background: #1976d2; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    üìÑ Export JSON Report
                </button>
                <button onclick="refreshAnalytics()" style="padding: 10px 20px; margin: 5px; background: #388e3c; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    üîÑ Refresh Analytics
                </button>
                <button onclick="showDeveloperMetrics()" style="padding: 10px 20px; margin: 5px; background: #7b1fa2; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    üîß Developer Metrics
                </button>
            </div>
        </div>
    </div>
    
    <!-- Tournament Modal -->
    <div id="tournamentModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5);">
        <div style="background: white; margin: 5% auto; padding: 20px; width: 80%; max-width: 800px; border-radius: 10px; max-height: 80%; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #1976d2; margin: 0;">üèÜ Tournament Dashboard</h2>
                <button onclick="document.getElementById('tournamentModal').style.display='none'" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">‚úï</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                    <h3 style="margin-top: 0; color: #333;">üìä Tournament Stats</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #1976d2;" id="totalPlayers">0</div>
                            <div style="color: #666;">Total Players</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold; color: #1976d2;" id="totalMatches">0</div>
                            <div style="color: #666;">Completed Matches</div>
                        </div>
                    </div>
                </div>
                
                <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                    <h3 style="margin-top: 0; color: #333;">‚ûï Create Player</h3>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="newPlayerName" placeholder="Enter player name" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <button onclick="createTournamentPlayer()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Create</button>
                    </div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h3 style="color: #333; margin-bottom: 15px;">üèÖ Leaderboard</h3>
                    <div id="leaderboard" style="max-height: 300px; overflow-y: auto;">
                        <!-- Leaderboard will be populated here -->
                    </div>
                </div>
                
                <div>
                    <h3 style="color: #333; margin-bottom: 15px;">‚öîÔ∏è Quick Match</h3>
                    <div style="background: #f9f9f9; padding: 15px; border-radius: 8px;">
                        <p style="color: #666; margin: 0 0 15px 0;">Select two players for a quick match</p>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <input type="text" id="player1Name" placeholder="Player 1 name" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <input type="text" id="player2Name" placeholder="Player 2 name" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        <button onclick="createQuickMatch()" style="background: #FF9800; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; width: 100%;">üéÆ Start Match</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        console.log('Main page script loading...');
        
        // Global variables (will be updated from dropdown values on page load)
        let currentDifficulty = 'random';  // Default fallback
        let currentStrategy = 'balanced';  // Match dropdown default
        let currentPersonality = 'neutral';  // Match dropdown default
        
        // Chart variables
        let moveDistributionChart = null;
        let winRateTrendChart = null;
        let strategyTimelineChart = null;
        let modelPredictionChart = null;
        let modelAccuracyChart = null;
        let confidenceTrendChart = null;
        
        // Initialize charts when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing charts...');
            
            // Get actual dropdown values instead of relying on template variables
            currentDifficulty = document.getElementById('difficulty').value;
            currentStrategy = document.getElementById('strategy').value;
            currentPersonality = document.getElementById('personality').value;
            
            console.log('Initial dropdown values:', {
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality
            });
            
            setTimeout(initializeCharts, 100); // Small delay to ensure DOM is ready
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            setTimeout(() => updateRobotConversation(currentPersonality, 'start'), 200);
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            console.log('Key pressed:', e.key);
            if (e.key === 'p' || e.key === 'P') submitMove('paper');
            if (e.key === 'r' || e.key === 'R') submitMove('stone'); // Rock = Stone
            if (e.key === 's' || e.key === 'S') submitMove('scissor');
        });
        
        // Game functions
        function submitMove(move) {
            console.log('submitMove called with:', move);
            
            // Reset the battle arena for new round
            resetMoveDisplay();
            
            const payload = {
                move: move,
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality
            };
            
            console.log('Sending payload:', payload);
            
            fetch('/play', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            })
            .then(res => {
                console.log('Response status:', res.status);
                return res.json();
            })
            .then(data => {
                console.log('Received data:', data);
                updateUI(data);
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = 
                    '<p style="color: red;">Error: ' + error.message + '</p>';
            });
        }
        
        function updateUI(data) {
            console.log('Updating UI with:', data);
            
            // Safely get the last human move
            const lastHumanMove = data.human_history && data.human_history.length > 0 
                ? data.human_history[data.human_history.length-1] 
                : 'unknown';
            
            // Safely get the robot move
            const robotMove = data.robot_move || 'unknown';
            
            // Safely get the result
            const result = data.result ? String(data.result) : 'unknown';
            
            // Update result
            document.getElementById('result').innerHTML = 
                '<h3>Round ' + (data.round || 0) + ' Results</h3>' +
                '<p>You played: <strong>' + lastHumanMove.toUpperCase() + '</strong></p>' +
                '<p>Computer played: <strong>' + robotMove.toUpperCase() + '</strong></p>' +
                '<p>Result: <strong>' + result.toUpperCase() + '</strong></p>';
            
            // Update stats safely
            const stats = data.stats || {};
            document.getElementById('rounds').textContent = data.round || 0;
            document.getElementById('human-wins').textContent = stats.human_win || 0;
            document.getElementById('robot-wins').textContent = stats.robot_win || 0;
            document.getElementById('ties').textContent = stats.tie || 0;
            
            // Update recent history safely
            const recentHuman = data.human_history ? data.human_history.slice(-10).join(', ') : '';
            const recentRobot = data.robot_history ? data.robot_history.slice(-10).join(', ') : '';
            document.getElementById('recent-human').textContent = recentHuman;
            document.getElementById('recent-robot').textContent = recentRobot;
            
            // Update strategy display
            if (data.current_strategy) {
                const strategy = String(data.current_strategy);
                document.getElementById('current-strategy-text').textContent = 
                    strategy.charAt(0).toUpperCase() + strategy.slice(1);
            }
            
            // Auto-refresh coaching tips every 5 rounds
            if (data.round && data.round > 0 && data.round % 5 === 0) {
                setTimeout(refreshCoachingTips, 500); // Small delay to ensure data is processed
            }
            
            // Update analytics dashboard
            updateAnalyticsDashboard(data);
            
            // Update charts
            updateCharts(data);
            
            // Update move display window
            updateMoveDisplay(lastHumanMove, robotMove, result);
            
            // Update robot conversation based on result
            const conversationEventType = result === 'human' ? 'lose' : result === 'robot' ? 'win' : 'tie';
            setTimeout(() => {
                updateRobotConversation(currentPersonality, conversationEventType, {
                    humanMove: lastHumanMove,
                    robotMove: robotMove,
                    round: data.round
                });
            }, 800); // Delay to let move display finish
        }
        
        // Move Display Window Functions
        function updateMoveDisplay(humanMove, robotMove, result) {
            // Update human move
            updatePlayerMove('human', humanMove);
            
            // Update robot move with a shorter delay for faster loading
            setTimeout(() => {
                updatePlayerMove('robot', robotMove);
                // Show result immediately after robot move is displayed
                setTimeout(() => {
                    showRoundResult(result, humanMove, robotMove);
                }, 150);
            }, 200);
        }
        
        function updatePlayerMove(player, move) {
            const moveImg = document.getElementById(player + '-move-img');
            const moveText = document.getElementById(player + '-move-text');
            
            if (move && move !== 'unknown') {
                // Set the correct image
                const imageMap = {
                    'stone': '/static/stone.png',
                    'paper': '/static/paper.png',
                    'scissor': '/static/scissor.png'
                };
                
                moveImg.src = imageMap[move.toLowerCase()] || '/static/paper.png';
                moveImg.style.display = 'block';
                moveText.textContent = move.charAt(0).toUpperCase() + move.slice(1);
            } else {
                moveImg.style.display = 'none';
                moveText.textContent = player === 'human' ? 'Choose your move' : 'Thinking...';
            }
        }
        
        function showRoundResult(result, humanMove, robotMove) {
            const resultDiv = document.getElementById('round-result');
            const humanDisplay = document.getElementById('human-move-display');
            const robotDisplay = document.getElementById('robot-move-display');
            
            // Reset borders
            humanDisplay.style.border = '2px solid transparent';
            robotDisplay.style.border = '2px solid transparent';
            
            // Show result and highlight winner
            if (result === 'human') {
                resultDiv.textContent = 'üéâ You Win!';
                resultDiv.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                resultDiv.style.color = 'white';
                humanDisplay.style.border = '2px solid #28a745';
                humanDisplay.style.boxShadow = '0 0 15px rgba(40, 167, 69, 0.4)';
            } else if (result === 'robot') {
                resultDiv.textContent = 'ü§ñ Robot Wins!';
                resultDiv.style.background = 'linear-gradient(135deg, #dc3545, #e83e8c)';
                resultDiv.style.color = 'white';
                robotDisplay.style.border = '2px solid #dc3545';
                robotDisplay.style.boxShadow = '0 0 15px rgba(220, 53, 69, 0.4)';
            } else {
                resultDiv.textContent = 'ü§ù It\'s a Tie!';
                resultDiv.style.background = 'linear-gradient(135deg, #ffc107, #fd7e14)';
                resultDiv.style.color = 'white';
                humanDisplay.style.border = '2px solid #ffc107';
                robotDisplay.style.border = '2px solid #ffc107';
            }
            
            resultDiv.style.display = 'block';
            
            // Don't auto-reset - keep result until next move
        }
        
        function resetMoveDisplay() {
            // Hide images and reset text
            document.getElementById('human-move-img').style.display = 'none';
            document.getElementById('robot-move-img').style.display = 'none';
            document.getElementById('human-move-text').textContent = 'Choose your move';
            document.getElementById('robot-move-text').textContent = 'Thinking...';
            document.getElementById('round-result').style.display = 'none';
            
            // Reset borders and shadows
            const humanDisplay = document.getElementById('human-move-display');
            const robotDisplay = document.getElementById('robot-move-display');
            humanDisplay.style.border = '2px solid transparent';
            robotDisplay.style.border = '2px solid transparent';
            humanDisplay.style.boxShadow = 'none';
            robotDisplay.style.boxShadow = 'none';
        }
        
        // Robot Character Visualization Functions
        function updateRobotCharacter(difficulty, strategy, personality) {
            console.log('updateRobotCharacter called with:', difficulty, strategy, personality);
            updateRobotAvatar(difficulty, personality);
            updateStrategySymbol(strategy);
            updateRobotInfo(difficulty, strategy, personality);
        }
        
        function updateRobotAvatar(difficulty, personality) {
            const avatar = document.getElementById('robot-avatar');
            console.log('updateRobotAvatar - element found:', avatar, 'difficulty:', difficulty, 'personality:', personality);
            
            if (!avatar) {
                console.error('robot-avatar element not found!');
                return;
            }
            
            // Personality character mapping
            const personalityChars = {
                'neutral': 'ü§ñ',
                'berserker': 'üíÄ',
                'guardian': 'üõ°Ô∏è', 
                'chameleon': 'ü¶é',
                'professor': 'üéì',
                'wildcard': 'üÉè',
                'mirror': 'ü™û',
                'balanced': 'ü§ñ'
            };
            
            // Difficulty-based background shading
            const difficultyStyles = {
                'random': {
                    background: 'linear-gradient(135deg, #e8f5e8, #d4edda)',
                    border: '3px solid #28a745'
                },
                'frequency': {
                    background: 'linear-gradient(135deg, #fff3cd, #ffeaa7)',
                    border: '3px solid #ffc107'
                },
                'markov': {
                    background: 'linear-gradient(135deg, #f8d7da, #f5b7b1)',
                    border: '3px solid #dc3545'
                },
                'enhanced': {
                    background: 'linear-gradient(135deg, #f3e5f5, #e1bee7)',
                    border: '3px solid #9c27b0'
                },
                'lstm': {
                    background: 'linear-gradient(135deg, #2c2c2c, #1a1a1a)',
                    border: '3px solid #6f42c1'
                }
            };
            
            // Update character
            const char = personalityChars[personality] || 'ü§ñ';
            console.log('Setting avatar char:', char);
            avatar.textContent = char;
            
            // Update styling
            const style = difficultyStyles[difficulty] || difficultyStyles['random'];
            console.log('Setting avatar style:', style);
            avatar.style.background = style.background;
            avatar.style.border = style.border;
        }
        
        function updateStrategySymbol(strategy) {
            const symbolElement = document.getElementById('strategy-symbol');
            console.log('updateStrategySymbol - element found:', symbolElement, 'strategy:', strategy);
            
            if (!symbolElement) {
                console.error('strategy-symbol element not found!');
                return;
            }
            
            // Strategy symbol mapping
            const strategySymbols = {
                'random': 'üé≤',
                'frequency': 'üìä',
                'pattern': 'üîÑ',
                'markov': 'üß†',
                'minimax': '‚öîÔ∏è',
                'lstm': 'ü§ñ',
                'balanced': '‚öñÔ∏è',
                'to_win': '‚öîÔ∏è',
                'not_to_lose': 'üõ°Ô∏è'
            };
            
            const symbol = strategySymbols[strategy] || '‚öîÔ∏è';
            console.log('Setting symbol to:', symbol);
            symbolElement.textContent = symbol;
        }
        
        function updateRobotInfo(difficulty, strategy, personality) {
            console.log('updateRobotInfo called with:', difficulty, strategy, personality);
            
            // Generate robot name based on personality and difficulty
            const names = {
                'neutral': ['Standard', 'Basic', 'Default', 'Unit'],
                'berserker': ['Destroyer', 'Annihilator', 'Crusher', 'Devastator'],
                'guardian': ['Protector', 'Defender', 'Shield', 'Bulwark'],
                'chameleon': ['Shifter', 'Adapter', 'Morph', 'Mimic'],
                'professor': ['Analyst', 'Scholar', 'Calculator', 'Logic'],
                'wildcard': ['Chaos', 'Random', 'Surprise', 'Wildfire'],
                'mirror': ['Echo', 'Reflection', 'Shadow', 'Copy'],
                'balanced': ['Standard', 'Basic', 'Default', 'Unit']
            };
            
            const nameList = names[personality] || names['neutral'];
            const baseName = nameList[Math.floor(Math.random() * nameList.length)];
            const difficultyPrefix = {
                'random': 'Basic',
                'frequency': 'Junior', 
                'markov': 'Advanced',
                'enhanced': 'Master',
                'lstm': 'Legendary'
            };
            
            const difficultyNames = {
                'random': 'Random',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'enhanced': 'Enhanced ML',
                'lstm': 'LSTM Neural Network'
            };
            
            const strategyNames = {
                'balanced': 'Balanced',
                'to_win': 'Aggressive (To Win)',
                'not_to_lose': 'Defensive (Not to Lose)'
            };
            
            const personalityNames = {
                'neutral': 'Neutral',
                'berserker': 'The Berserker',
                'guardian': 'The Guardian',
                'chameleon': 'The Chameleon',
                'professor': 'The Professor',
                'wildcard': 'The Wildcard',
                'mirror': 'The Mirror'
            };
            
            const robotName = `${difficultyPrefix[difficulty] || 'Basic'} ${baseName}`;
            
            console.log('Updating robot display with:', {
                robotName,
                difficulty: difficultyNames[difficulty] || difficulty,
                strategy: strategyNames[strategy] || strategy,
                personality: personalityNames[personality] || personality
            });
            
            // Update display with proper names
            const robotNameElement = document.getElementById('robot-name');
            const robotDifficultyElement = document.getElementById('robot-difficulty');
            const robotStrategyElement = document.getElementById('robot-strategy');
            const robotPersonalityElement = document.getElementById('robot-personality');
            
            if (robotNameElement) robotNameElement.textContent = robotName;
            if (robotDifficultyElement) robotDifficultyElement.textContent = difficultyNames[difficulty] || difficulty;
            if (robotStrategyElement) robotStrategyElement.textContent = strategyNames[strategy] || strategy;
            if (robotPersonalityElement) robotPersonalityElement.textContent = personalityNames[personality] || personality;
            
            console.log('Robot info updated successfully');
        }
        
        // Robot Conversation System Functions
        function updateRobotConversation(personality, eventType, data = {}) {
            const speechElement = document.getElementById('robot-speech');
            const moodElement = document.getElementById('robot-mood');
            const avatarElement = document.getElementById('conversation-avatar');
            
            const dialogue = generatePersonalityDialogue(personality, eventType, data);
            
            // Update speech with typing effect
            typeMessage(speechElement, dialogue.message);
            
            // Update mood and avatar
            moodElement.textContent = dialogue.mood;
            avatarElement.textContent = dialogue.avatar;
        }
        
        function generatePersonalityDialogue(personality, eventType, data) {
            const dialogues = {
                'berserker': {
                    'start': {
                        messages: ["CRUSH YOUR ENEMIES!", "No mercy! Let's fight!", "I will dominate this battle!", "Prepare for destruction!"],
                        mood: "üíÄ Bloodthirsty",
                        avatar: "üíÄ"
                    },
                    'win': {
                        messages: ["VICTORY IS MINE!", "Another victim falls!", "Bow before my might!", "Total annihilation!"],
                        mood: "üëπ Triumphant",
                        avatar: "üëπ"
                    },
                    'lose': {
                        messages: ["IMPOSSIBLE! I demand a rematch!", "This rage fuels my power!", "You got lucky this time!", "I will have my revenge!"],
                        mood: "üò° Furious",
                        avatar: "üò°"
                    },
                    'tie': {
                        messages: ["We're equally matched!", "The battle continues!", "Neither yields!", "This proves nothing!"],
                        mood: "‚öîÔ∏è Intense",
                        avatar: "‚öîÔ∏è"
                    }
                },
                'guardian': {
                    'start': {
                        messages: ["I shall protect my honor!", "Defense is the best strategy!", "Stand firm and endure!", "My shield is unbreakable!"],
                        mood: "üõ°Ô∏è Steadfast",
                        avatar: "üõ°Ô∏è"
                    },
                    'win': {
                        messages: ["A well-defended victory!", "Patience and defense prevail!", "Honor is preserved!", "The shield holds strong!"],
                        mood: "üèÜ Honorable",
                        avatar: "üèÜ"
                    },
                    'lose': {
                        messages: ["I fought with honor!", "Sometimes the shield fails...", "Your strategy was admirable!", "I must strengthen my defense!"],
                        mood: "üí™ Resolute",
                        avatar: "üí™"
                    },
                    'tie': {
                        messages: ["A noble stalemate!", "Both warriors show courage!", "Evenly matched defenses!", "Honor to both sides!"],
                        mood: "ü§ù Respectful",
                        avatar: "ü§ù"
                    }
                },
                'chameleon': {
                    'start': {
                        messages: ["Adapting to your style...", "Let me observe your patterns!", "I'll match your energy!", "Time to blend strategies!"],
                        mood: "ü¶é Adaptive",
                        avatar: "ü¶é"
                    },
                    'win': {
                        messages: ["Perfect adaptation!", "I mirrored your weakness!", "Flexibility wins again!", "Change is my strength!"],
                        mood: "üéØ Precise",
                        avatar: "üéØ"
                    },
                    'lose': {
                        messages: ["Interesting... recalibrating!", "Your unpredictability impressed me!", "Time to adapt further!", "Learning from this defeat!"],
                        mood: "üîÑ Evolving",
                        avatar: "üîÑ"
                    },
                    'tie': {
                        messages: ["We adapted to each other!", "Perfectly balanced strategies!", "Mutual adaptation!", "Synchronized thinking!"],
                        mood: "‚öñÔ∏è Balanced",
                        avatar: "‚öñÔ∏è"
                    }
                },
                'professor': {
                    'start': {
                        messages: ["Let's analyze this scientifically!", "Fascinating tactical possibilities!", "Time for logical deduction!", "The data suggests..."],
                        mood: "üî¨ Analytical",
                        avatar: "üéì"
                    },
                    'win': {
                        messages: ["Hypothesis confirmed!", "The calculations were correct!", "Logic prevails once again!", "A predictable outcome!"],
                        mood: "üß† Satisfied",
                        avatar: "üß†"
                    },
                    'lose': {
                        messages: ["Intriguing! An anomaly to study!", "Unexpected variables detected!", "This requires further analysis!", "Statistical outlier noted!"],
                        mood: "ü§î Curious",
                        avatar: "ü§î"
                    },
                    'tie': {
                        messages: ["Statistically balanced outcome!", "Equilibrium achieved!", "Perfect probability distribution!", "Fascinating data point!"],
                        mood: "üìä Logical",
                        avatar: "üìä"
                    }
                },
                'wildcard': {
                    'start': {
                        messages: ["Chaos time! Expect anything!", "Rules? What rules?!", "Let's shake things up!", "Random madness incoming!"],
                        mood: "üÉè Chaotic",
                        avatar: "üÉè"
                    },
                    'win': {
                        messages: ["BOOM! Didn't see that coming!", "Chaos reigns supreme!", "Random victory dance!", "Unpredictability wins!"],
                        mood: "üéâ Ecstatic",
                        avatar: "üéâ"
                    },
                    'lose': {
                        messages: ["Whoops! That was unexpected!", "Plot twist! You got me!", "Chaos works both ways!", "Random defeat... or is it?"],
                        mood: "ü§™ Amused",
                        avatar: "ü§™"
                    },
                    'tie': {
                        messages: ["What are the odds?!", "Chaos creates balance!", "Perfectly random outcome!", "Even randomness has patterns!"],
                        mood: "üé≤ Surprised",
                        avatar: "üé≤"
                    }
                },
                'mirror': {
                    'start': {
                        messages: ["I reflect your every move!", "Mirror mirror on the wall...", "Your style becomes mine!", "Copying... initializing..."],
                        mood: "ü™û Mirroring",
                        avatar: "ü™û"
                    },
                    'win': {
                        messages: ["I became you, but better!", "Perfect reflection achieved!", "Your own moves defeated you!", "Mirror mastery complete!"],
                        mood: "‚ú® Reflected",
                        avatar: "‚ú®"
                    },
                    'lose': {
                        messages: ["You broke the mirror!", "Reflection incomplete...", "My copy wasn't perfect!", "Time to re-calibrate reflection!"],
                        mood: "üí´ Fragmented",
                        avatar: "üí´"
                    },
                    'tie': {
                        messages: ["Perfect mirror match!", "Two reflections collide!", "We are the same!", "Mirror meets mirror!"],
                        mood: "üîÑ Synchronized",
                        avatar: "üîÑ"
                    }
                },
                'neutral': {
                    'start': {
                        messages: ["Ready for battle? Let's play!", "I'll analyze your patterns.", "May the best strategy win!", "Game on!"],
                        mood: "ü§ñ Ready",
                        avatar: "ü§ñ"
                    },
                    'win': {
                        messages: ["Good game! I predicted correctly.", "My analysis paid off!", "Strategy successful!", "Well played!"],
                        mood: "üòä Satisfied",
                        avatar: "üòä"
                    },
                    'lose': {
                        messages: ["Nice move! You got me there.", "Impressive strategy!", "I'll adapt for next time.", "You outplayed me!"],
                        mood: "ü§î Analyzing",
                        avatar: "ü§î"
                    },
                    'tie': {
                        messages: ["Great minds think alike!", "Even match!", "Balanced strategies!", "Perfect tie!"],
                        mood: "‚öñÔ∏è Balanced",
                        avatar: "‚öñÔ∏è"
                    }
                }
            };
            
            const personalityData = dialogues[personality] || dialogues['neutral'] || dialogues['berserker'];
            const eventData = personalityData[eventType] || personalityData['start'];
            
            return {
                message: eventData.messages[Math.floor(Math.random() * eventData.messages.length)],
                mood: eventData.mood,
                avatar: eventData.avatar
            };
        }
        
        function typeMessage(element, message) {
            element.textContent = '';
            let i = 0;
            const typingSpeed = 30; // ms per character
            
            function typeChar() {
                if (i < message.length) {
                    element.textContent += message.charAt(i);
                    i++;
                    setTimeout(typeChar, typingSpeed);
                }
            }
            
            typeChar();
        }
        
        // Advanced Analytics Functions
        function updateAnalyticsDashboard(data) {
            if (!data.human_history || data.human_history.length === 0) return;
            
            const history = data.human_history;
            const totalMoves = history.length;
            
            // Calculate move distribution
            const paperCount = history.filter(m => m === 'paper').length;
            const stoneCount = history.filter(m => m === 'stone').length;
            const scissorCount = history.filter(m => m === 'scissor').length;
            
            const paperPercent = ((paperCount / totalMoves) * 100).toFixed(1);
            const stonePercent = ((stoneCount / totalMoves) * 100).toFixed(1);
            const scissorPercent = ((scissorCount / totalMoves) * 100).toFixed(1);
            
            // Update move distribution bars
            document.getElementById('paper-fill').style.width = paperPercent + '%';
            document.getElementById('rock-fill').style.width = stonePercent + '%';
            document.getElementById('scissor-fill').style.width = scissorPercent + '%';
            
            document.getElementById('paper-percent').textContent = paperPercent + '%';
            document.getElementById('rock-percent').textContent = stonePercent + '%';
            document.getElementById('scissor-percent').textContent = scissorPercent + '%';
            
            // Calculate predictability score
            const maxPercent = Math.max(paperPercent, stonePercent, scissorPercent);
            const predictabilityScore = maxPercent;
            document.getElementById('predictability-score').textContent = predictabilityScore + '%';
            
            let predictabilityStatus = 'Highly Unpredictable';
            if (predictabilityScore > 50) predictabilityStatus = 'Somewhat Predictable';
            if (predictabilityScore > 70) predictabilityStatus = 'Very Predictable';
            document.getElementById('predictability-status').textContent = predictabilityStatus;
            
            // Calculate recent win rate trend
            const recentGames = Math.min(10, data.round);
            const recentWins = data.stats ? data.stats.human_win : 0;
            const winRate = data.round > 0 ? ((recentWins / data.round) * 100).toFixed(1) : 0;
            document.getElementById('win-rate-trend').textContent = winRate + '%';
            
            // Calculate randomness level (entropy)
            const p1 = paperCount / totalMoves;
            const p2 = stoneCount / totalMoves;
            const p3 = scissorCount / totalMoves;
            let entropy = 0;
            if (p1 > 0) entropy -= p1 * Math.log2(p1);
            if (p2 > 0) entropy -= p2 * Math.log2(p2);
            if (p3 > 0) entropy -= p3 * Math.log2(p3);
            const randomnessPercent = ((entropy / Math.log2(3)) * 100).toFixed(1);
            document.getElementById('randomness-level').textContent = randomnessPercent + '%';
            
            let randomnessStatus = 'Low Randomness';
            if (randomnessPercent > 60) randomnessStatus = 'Medium Randomness';
            if (randomnessPercent > 80) randomnessStatus = 'High Randomness';
            document.getElementById('randomness-status').textContent = randomnessStatus;
            
            // Strategy changes (placeholder)
            document.getElementById('strategy-changes-count').textContent = Math.floor(data.round / 7) || 0;
        }
        
        function refreshAnalytics() {
            console.log('Refreshing analytics...');
            fetch('/history')
            .then(res => res.json())
            .then(data => {
                console.log('Analytics data received:', data);
                updateAnalyticsDashboard(data);
            })
            .catch(err => console.log('Analytics refresh failed:', err));
        }
        
        function updateStatusDisplay() {
            // Update the game status to show current AI configuration
            const strategyText = {
                'balanced': 'Balanced Strategy',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const personalityText = {
                'neutral': 'Neutral Personality',
                'aggressive': 'Aggressive Personality',
                'defensive': 'Defensive Personality',
                'adaptive': 'Adaptive Personality',
                'chaotic': 'Chaotic Personality',
                'copycat': 'Copycat Personality'
            };
            
            console.log(`AI Config: ${currentDifficulty} + ${strategyText[currentStrategy]} + ${personalityText[currentPersonality]}`);
        }
        
        function applyPersonalityTheme(personality) {
            // Remove existing personality classes
            document.body.classList.remove('personality-aggressive', 'personality-defensive', 'personality-adaptive', 'personality-chaotic', 'personality-copycat');
            
            // Apply new personality theme
            if (personality !== 'neutral') {
                document.body.classList.add(`personality-${personality}`);
            }
            
            // Update UI elements based on personality
            const gameContainer = document.querySelector('.game-container');
            if (gameContainer) {
                const themes = {
                    'neutral': { borderColor: '#ddd', backgroundColor: '#fff' },
                    'aggressive': { borderColor: '#ff4444', backgroundColor: '#fff5f5' },
                    'defensive': { borderColor: '#4444ff', backgroundColor: '#f5f5ff' },
                    'adaptive': { borderColor: '#9944ff', backgroundColor: '#faf5ff' },
                    'chaotic': { borderColor: '#ff8844', backgroundColor: '#fff8f5' },
                    'copycat': { borderColor: '#44ff44', backgroundColor: '#f5fff5' }
                };
                
                const theme = themes[personality] || themes['neutral'];
                gameContainer.style.borderColor = theme.borderColor;
                gameContainer.style.backgroundColor = theme.backgroundColor;
            }
        }
        
        function exportAnalytics(format) {
            console.log('Exporting analytics in format:', format);
            fetch('/analytics/export?format=' + format)
            .then(res => res.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.' + format;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(err => {
                console.log('Export failed, creating manual export:', err);
                // Fallback: create manual JSON export
                const analyticsData = {
                    timestamp: new Date().toISOString(),
                    total_games: parseInt(document.getElementById('rounds').textContent) || 0,
                    predictability_score: document.getElementById('predictability-score').textContent,
                    win_rate: document.getElementById('win-rate-trend').textContent,
                    randomness_level: document.getElementById('randomness-level').textContent,
                    move_distribution: {
                        paper: document.getElementById('paper-percent').textContent,
                        rock: document.getElementById('rock-percent').textContent,
                        scissor: document.getElementById('scissor-percent').textContent
                    }
                };
                const dataStr = JSON.stringify(analyticsData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.json';
                a.click();
            });
        }
        
        function showDeveloperMetrics() {
            const metrics = {
                'Page Load Time': 'Fast',
                'API Response Time': 'Good',
                'JavaScript Errors': 'None',
                'Memory Usage': 'Normal',
                'Network Requests': 'Optimized'
            };
            
            let metricsHtml = '<h4>üîß Developer Metrics Console</h4>';
            for (const [key, value] of Object.entries(metrics)) {
                metricsHtml += `<p><strong>${key}:</strong> ${value}</p>`;
            }
            metricsHtml += '<p><em>All systems operational</em></p>';
            
            alert('Developer Metrics:\n\n' + Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join('\n'));
        }
        
        // Chart Functions
        function initializeCharts() {
            console.log('Initializing charts...');
            try {
                // Move Distribution Pie Chart
                const moveCtx = document.getElementById('moveDistributionChart');
                if (moveCtx) {
                    moveDistributionChart = new Chart(moveCtx, {
                        type: 'pie',
                        data: {
                            labels: ['Paper (P)', 'Rock (R)', 'Scissor (S)'],
                            datasets: [{
                                data: [0, 0, 0],
                                backgroundColor: ['#4CAF50', '#FF9800', '#F44336'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
                
                // Win Rate Trend Line Chart
                const winCtx = document.getElementById('winRateTrendChart');
                if (winCtx) {
                    winRateTrendChart = new Chart(winCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Win Rate %',
                                data: [],
                                borderColor: '#1976D2',
                                backgroundColor: 'rgba(25, 118, 210, 0.1)',
                                fill: true,
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    ticks: {
                                        callback: function(value) {
                                            return value + '%';
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Strategy Timeline Bar Chart
                const strategyCtx = document.getElementById('strategyTimelineChart');
                if (strategyCtx) {
                    strategyTimelineChart = new Chart(strategyCtx, {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Strategy Usage',
                                data: [],
                                backgroundColor: '#9C27B0',
                                borderColor: '#7B1FA2',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Model Prediction Chart
                const modelCtx = document.getElementById('modelPredictionChart');
                if (modelCtx) {
                    modelPredictionChart = new Chart(modelCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Human Move',
                                    data: [],
                                    borderColor: '#FF6384',
                                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4
                                },
                                {
                                    label: 'Robot Move',
                                    data: [],
                                    borderColor: '#36A2EB',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4
                                },
                                {
                                    label: 'Random Prediction',
                                    data: [],
                                    borderColor: '#FFCE56',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Frequency Prediction',
                                    data: [],
                                    borderColor: '#4BC0C0',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Markov Prediction',
                                    data: [],
                                    borderColor: '#9966FF',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Enhanced Prediction',
                                    data: [],
                                    borderColor: '#FF9F40',
                                    backgroundColor: 'rgba(255, 159, 64, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: {
                                            size: 11
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Move Number'
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Move Type'
                                    },
                                    min: -0.5,
                                    max: 2.5,
                                    ticks: {
                                        stepSize: 1,
                                        callback: function(value) {
                                            if (value === 0) return 'Scissor';
                                            if (value === 1) return 'Rock';
                                            if (value === 2) return 'Paper';
                                            return '';
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Model Accuracy Comparison Chart
                const accuracyCtx = document.getElementById('modelAccuracyChart');
                if (accuracyCtx) {
                    modelAccuracyChart = new Chart(accuracyCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Random', 'Frequency', 'Markov', 'Enhanced', 'LSTM'],
                            datasets: [{
                                label: 'Accuracy (%)',
                                data: [0, 0, 0, 0, 0],
                                backgroundColor: [
                                    'rgba(255, 206, 86, 0.8)',
                                    'rgba(75, 192, 192, 0.8)',
                                    'rgba(153, 102, 255, 0.8)',
                                    'rgba(255, 159, 64, 0.8)',
                                    'rgba(54, 162, 235, 0.8)'
                                ],
                                borderColor: [
                                    'rgba(255, 206, 86, 1)',
                                    'rgba(75, 192, 192, 1)',
                                    'rgba(153, 102, 255, 1)',
                                    'rgba(255, 159, 64, 1)',
                                    'rgba(54, 162, 235, 1)'
                                ],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    title: {
                                        display: true,
                                        text: 'Accuracy (%)'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Confidence Trend Chart
                const confidenceCtx = document.getElementById('confidenceTrendChart');
                if (confidenceCtx) {
                    confidenceTrendChart = new Chart(confidenceCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Random',
                                    data: [],
                                    borderColor: 'rgba(255, 206, 86, 1)',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Frequency',
                                    data: [],
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Markov',
                                    data: [],
                                    borderColor: 'rgba(153, 102, 255, 1)',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Enhanced',
                                    data: [],
                                    borderColor: 'rgba(255, 159, 64, 1)',
                                    backgroundColor: 'rgba(255, 159, 64, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'LSTM',
                                    data: [],
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: { size: 10 }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Move Number'
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    max: 1,
                                    title: {
                                        display: true,
                                        text: 'Confidence'
                                    }
                                }
                            }
                        }
                    });
                }
                
                console.log('Charts initialized successfully');
            } catch (error) {
                console.error('Error initializing charts:', error);
            }
        }
        
        function updateCharts(data) {
            if (!data.human_history || data.human_history.length === 0) return;
            
            try {
                // Update Move Distribution Chart
                if (moveDistributionChart) {
                    const history = data.human_history;
                    const paperCount = history.filter(m => m === 'paper').length;
                    const stoneCount = history.filter(m => m === 'stone').length;
                    const scissorCount = history.filter(m => m === 'scissor').length;
                    
                    moveDistributionChart.data.datasets[0].data = [paperCount, stoneCount, scissorCount];
                    moveDistributionChart.update('none'); // No animation for performance
                }
                
                // Update Win Rate Trend Chart
                if (winRateTrendChart && data.round > 0) {
                    const winRate = data.stats ? ((data.stats.human_win / data.round) * 100).toFixed(1) : 0;
                    
                    // Keep last 20 data points
                    if (winRateTrendChart.data.labels.length >= 20) {
                        winRateTrendChart.data.labels.shift();
                        winRateTrendChart.data.datasets[0].data.shift();
                    }
                    
                    winRateTrendChart.data.labels.push(`R${data.round}`);
                    winRateTrendChart.data.datasets[0].data.push(parseFloat(winRate));
                    winRateTrendChart.update('none');
                }
                
                // Update Strategy Timeline Chart (simplified)
                if (strategyTimelineChart) {
                    const strategies = ['Analyzing', 'Random', 'Frequency', 'Markov', 'Enhanced'];
                    const counts = strategies.map(() => Math.floor(Math.random() * data.round / 5 + 1));
                    
                    strategyTimelineChart.data.labels = strategies;
                    strategyTimelineChart.data.datasets[0].data = counts;
                    strategyTimelineChart.update('none');
                }
                
                // Update Model Prediction Chart
                if (modelPredictionChart && data.human_history && data.robot_history) {
                    const moveToNumber = (move) => {
                        if (move === 'paper') return 2;
                        if (move === 'stone' || move === 'rock') return 1;
                        if (move === 'scissor') return 0;
                        return null;
                    };
                    
                    const humanData = data.human_history.map(moveToNumber);
                    const robotData = data.robot_history.map(moveToNumber);
                    
                    // Use real model predictions from backend
                    const modelPreds = data.model_predictions_history || {};
                    const randomPreds = (modelPreds.random || []).map(moveToNumber);
                    const frequencyPreds = (modelPreds.frequency || []).map(moveToNumber);
                    const markovPreds = (modelPreds.markov || []).map(moveToNumber);
                    const enhancedPreds = (modelPreds.enhanced || []).map(moveToNumber);
                    
                    const labels = Array.from({length: humanData.length}, (_, i) => i + 1);
                    
                    modelPredictionChart.data.labels = labels;
                    modelPredictionChart.data.datasets[0].data = humanData; // Human moves
                    modelPredictionChart.data.datasets[1].data = robotData; // Robot moves
                    modelPredictionChart.data.datasets[2].data = randomPreds; // Random predictions
                    modelPredictionChart.data.datasets[3].data = frequencyPreds; // Frequency predictions
                    modelPredictionChart.data.datasets[4].data = markovPreds; // Markov predictions
                    modelPredictionChart.data.datasets[5].data = enhancedPreds; // Enhanced predictions
                    
                    modelPredictionChart.update('none');
                }
                
                // Update Model Accuracy Chart
                if (modelAccuracyChart && data.accuracy) {
                    const accuracyData = [
                        data.accuracy.random || 0,
                        data.accuracy.frequency || 0, 
                        data.accuracy.markov || 0,
                        data.accuracy.enhanced || 0,
                        data.accuracy.lstm || 0
                    ];
                    modelAccuracyChart.data.datasets[0].data = accuracyData;
                    modelAccuracyChart.update('none');
                }
                
                // Update Confidence Trend Chart
                if (confidenceTrendChart && data.confidence !== undefined) {
                    const moveNum = data.round;
                    
                    // Simulate confidence values for different models (in real implementation, track actual confidence)
                    const confidenceValues = {
                        random: 0.33,
                        frequency: Math.min(0.8, 0.3 + (data.round * 0.02)),
                        markov: Math.min(0.85, 0.4 + (data.round * 0.015)),
                        enhanced: data.confidence || 0.5,
                        lstm: Math.min(0.9, 0.5 + (data.round * 0.01))
                    };
                    
                    if (confidenceTrendChart.data.labels.length > 20) {
                        // Keep only last 20 moves for performance
                        confidenceTrendChart.data.labels.shift();
                        confidenceTrendChart.data.datasets.forEach(dataset => dataset.data.shift());
                    }
                    
                    confidenceTrendChart.data.labels.push(moveNum);
                    confidenceTrendChart.data.datasets[0].data.push(confidenceValues.random);
                    confidenceTrendChart.data.datasets[1].data.push(confidenceValues.frequency);
                    confidenceTrendChart.data.datasets[2].data.push(confidenceValues.markov);
                    confidenceTrendChart.data.datasets[3].data.push(confidenceValues.enhanced);
                    confidenceTrendChart.data.datasets[4].data.push(confidenceValues.lstm);
                    confidenceTrendChart.update('none');
                }
                
                // Update Model Metrics Table
                updateModelMetrics(data);
                
                // Update Recommended Strategy
                updateRecommendedStrategy(data);
                
            } catch (error) {
                console.error('Error updating charts:', error);
            }
        }
        
        // Model Metrics Functions
        function updateModelMetrics(data) {
            const metricsContainer = document.getElementById('modelMetricsTable');
            if (!metricsContainer || !data.accuracy) return;
            
            const models = [
                { name: 'Random', key: 'random', color: '#FFCE56' },
                { name: 'Frequency', key: 'frequency', color: '#4BC0C0' },
                { name: 'Markov', key: 'markov', color: '#9966FF' },
                { name: 'Enhanced', key: 'enhanced', color: '#FF9F40' },
                { name: 'LSTM Neural', key: 'lstm', color: '#36A2EB' }
            ];
            
            metricsContainer.innerHTML = models.map(model => {
                const accuracy = data.accuracy[model.key] || 0;
                const correct = data.correct_predictions?.[model.key] || 0;
                const total = data.total_predictions?.[model.key] || 0;
                
                return `
                    <div style="background: linear-gradient(135deg, ${model.color}20, ${model.color}10); border-left: 4px solid ${model.color}; padding: 15px; border-radius: 8px;">
                        <h6 style="margin: 0 0 8px 0; color: #333; font-weight: bold;">${model.name} Strategy</h6>
                        <div style="font-size: 24px; font-weight: bold; color: ${model.color}; margin-bottom: 5px;">${accuracy.toFixed(1)}%</div>
                        <div style="color: #666; font-size: 12px;">
                            Predictions: ${correct}/${total}<br>
                            Status: ${accuracy > 60 ? 'üü¢ Excellent' : accuracy > 40 ? 'üü° Good' : 'üî¥ Needs Improvement'}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateRecommendedStrategy(data) {
            const recommendationEl = document.getElementById('recommendedStrategy');
            if (!recommendationEl || !data.accuracy) return;
            
            const accuracies = data.accuracy;
            const bestModel = Object.keys(accuracies).reduce((best, current) => 
                (accuracies[current] || 0) > (accuracies[best] || 0) ? current : best
            );
            
            const bestAccuracy = accuracies[bestModel] || 0;
            const modelNames = {
                'random': 'Random Strategy',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'enhanced': 'Enhanced ML',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const recommendation = bestAccuracy > 60 ? 
                `üèÜ ${modelNames[bestModel]} (${bestAccuracy.toFixed(1)}% accuracy)` :
                `üîÑ Continue analyzing patterns (Best: ${modelNames[bestModel]} at ${bestAccuracy.toFixed(1)}%)`;
                
            recommendationEl.innerHTML = `
                <div style="color: ${bestAccuracy > 60 ? '#4CAF50' : '#FF9800'};">
                    ${recommendation}
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    ${data.round < 10 ? 'Play more rounds for better analysis' : 'Pattern analysis complete'}
                </div>
            `;
        }
        
        // Tournament Management Functions
        function showTournamentDashboard() {
            fetch('/tournament')
            .then(res => res.json())
            .then(data => {
                updateTournamentDashboard(data);
                document.getElementById('tournamentModal').style.display = 'block';
            })
            .catch(err => console.error('Error fetching tournament data:', err));
        }
        
        function updateTournamentDashboard(data) {
            // Update leaderboard
            const leaderboardHtml = data.leaderboard.map((player, index) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: ${index < 3 ? '#f0f8ff' : '#f9f9f9'}; margin: 5px 0; border-radius: 5px;">
                    <div>
                        <span style="font-weight: bold; color: ${index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#666'};">
                            #${index + 1}
                        </span>
                        ${player.name}
                    </div>
                    <div style="text-align: right;">
                        <div style="font-weight: bold;">${Math.round(player.elo_rating)}</div>
                        <div style="font-size: 12px; color: #666;">${player.wins}W-${player.losses}L</div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('leaderboard').innerHTML = leaderboardHtml;
            
            // Update stats
            document.getElementById('totalPlayers').textContent = data.total_players;
            document.getElementById('totalMatches').textContent = data.total_matches;
        }
        
        function createTournamentPlayer() {
            const name = document.getElementById('newPlayerName').value.trim();
            if (!name) {
                alert('Please enter a player name');
                return;
            }
            
            fetch('/tournament/player', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({name: name})
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('newPlayerName').value = '';
                    showTournamentDashboard(); // Refresh dashboard
                    alert(`Player "${data.player.name}" created successfully!`);
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(err => {
                console.error('Error creating player:', err);
                alert('Error creating player');
            });
        }
        
        function createQuickMatch() {
            const player1 = document.getElementById('player1Name').value.trim();
            const player2 = document.getElementById('player2Name').value.trim();
            
            if (!player1 || !player2) {
                alert('Please enter both player names');
                return;
            }
            
            fetch('/tournament/match', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    player1_name: player1,
                    player2_name: player2
                })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    alert(`Match created between ${player1} and ${player2}!`);
                    document.getElementById('player1Name').value = '';
                    document.getElementById('player2Name').value = '';
                    // You could redirect to a match interface here
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(err => {
                console.error('Error creating match:', err);
                alert('Error creating match');
            });
        }
        
        // Coaching Functions
        function refreshCoachingTips() {
            console.log('Refreshing coaching tips...');
            fetch('/coaching')
            .then(res => res.json())
            .then(data => {
                console.log('Coaching data received:', data);
                updateCoachingTips(data);
            })
            .catch(err => {
                console.log('Coaching tips unavailable:', err);
                document.getElementById('coaching-tips-list').innerHTML = 
                    '<p style="color: #666; font-style: italic;">Coaching tips will be available after more games.</p>';
            });
        }
        
        function updateCoachingTips(coachingData) {
            const tipsContainer = document.getElementById('coaching-tips-list');
            const experimentsContainer = document.getElementById('experiments-list');
            const insightsContainer = document.getElementById('insights-content');
            const insightsSummary = document.getElementById('insights-summary');
            
            // Update tips
            if (coachingData.coaching_tips && coachingData.coaching_tips.length > 0) {
                const tipsHtml = coachingData.coaching_tips.map((tip, index) => 
                    `<div style="margin-bottom: 12px; padding: 10px; background: rgba(255,152,0,0.1); border-radius: 6px;">
                        <strong>${index + 1}.</strong> ${tip}
                    </div>`
                ).join('');
                tipsContainer.innerHTML = tipsHtml;
            } else {
                tipsContainer.innerHTML = '<p style="color: #666; font-style: italic;">Keep playing to get personalized tips!</p>';
            }
            
            // Update experiments
            if (coachingData.experiments && coachingData.experiments.length > 0) {
                const experimentsHtml = coachingData.experiments.map(exp => 
                    `<div style="margin-bottom: 15px; padding: 12px; background: rgba(76,175,80,0.1); border-radius: 6px;">
                        <strong style="color: #2e7d32;">${exp.name}</strong><br>
                        <small style="color: #388e3c;">${exp.description}</small><br>
                        <em style="font-size: 13px; color: #4caf50;">${exp.strategy}</em>
                    </div>`
                ).join('');
                experimentsContainer.innerHTML = experimentsHtml;
            } else {
                experimentsContainer.innerHTML = '<p style="color: #666; font-style: italic;">Experiment suggestions coming soon!</p>';
            }
            
            // Update insights (optional)
            if (coachingData.insights && Object.keys(coachingData.insights).length > 0) {
                const insights = coachingData.insights;
                let insightsHtml = '';
                
                if (insights.predictability !== undefined) {
                    const predPercent = (insights.predictability * 100).toFixed(1);
                    insightsHtml += `<p><strong>Predictability:</strong> ${predPercent}% - `;
                    insightsHtml += insights.predictability > 0.6 ? 'Too predictable!' : 'Good unpredictability';
                    insightsHtml += '</p>';
                }
                
                if (insights.pattern_type) {
                    insightsHtml += `<p><strong>Pattern Type:</strong> ${insights.pattern_type.replace('_', ' ')}</p>`;
                }
                
                if (insights.recent_performance) {
                    const winRate = (insights.recent_performance.win_rate * 100).toFixed(1);
                    insightsHtml += `<p><strong>Recent Win Rate:</strong> ${winRate}%</p>`;
                }
                
                if (insightsHtml) {
                    insightsContainer.innerHTML = insightsHtml;
                    insightsSummary.style.display = 'block';
                } else {
                    insightsSummary.style.display = 'none';
                }
            } else {
                insightsSummary.style.display = 'none';
            }
        }
        
        function setDifficulty() {
            currentDifficulty = document.getElementById('difficulty').value;
            console.log('Difficulty set to:', currentDifficulty);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        function setStrategy() {
            currentStrategy = document.getElementById('strategy').value;
            console.log('Strategy set to:', currentStrategy);
            updateStatusDisplay();
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        function setPersonality() {
            currentPersonality = document.getElementById('personality').value;
            console.log('Personality set to:', currentPersonality);
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            updateRobotConversation(currentPersonality, 'start');
        }
        
        // DEBUG: Test function to manually trigger robot update
        function testRobotUpdate() {
            console.log('=== MANUAL TEST TRIGGERED ===');
            const diff = document.getElementById('difficulty').value;
            const strat = document.getElementById('strategy').value;
            const pers = document.getElementById('personality').value;
            
            console.log('Current dropdown values:', { diff, strat, pers });
            console.log('Current JS variables:', { currentDifficulty, currentStrategy, currentPersonality });
            
            // Update variables
            currentDifficulty = diff;
            currentStrategy = strat;
            currentPersonality = pers;
            
            console.log('Calling updateRobotCharacter...');
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        
        function resetGame() {
            fetch('/reset', {method: 'POST'})
            .then(res => res.json())
            .then(() => location.reload())
            .catch(error => {
                console.error('Reset error:', error);
                location.reload();
            });
        }
        
        // üéÆ ENHANCED REPLAY FUNCTIONS (New Feature #1)
        function saveCurrentReplay() {
            const name = prompt('Enter a name for this replay:', 'Game Session ' + new Date().toLocaleString());
            if (name) {
                const notes = prompt('Enter any notes (optional):', '');
                const formData = new FormData();
                formData.append('name', name);
                formData.append('notes', notes || '');
                
                fetch('/replay/save', {
                    method: 'POST',
                    body: formData
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        alert(`‚úÖ Replay saved successfully!\nSession ID: ${data.session_id}\nTotal rounds: ${data.total_rounds}`);
                    } else {
                        alert(`‚ùå Failed to save replay: ${data.message}`);
                    }
                })
                .catch(err => {
                    alert('‚ùå Error saving replay: ' + err.message);
                });
            }
        }
        
        console.log('Main page script loaded successfully');
    </script>
</body>
</html>
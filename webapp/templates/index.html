<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper Scissor Stone ML Game</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/experimental-theme.css') }}">
    <style>
        /* Disabled Tournament Button Styling */
        .disabled-tournament {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
            background: #666 !important;
            border-color: #555 !important;
        }
        .disabled-tournament:hover {
            background: #666 !important;
            transform: none !important;
        }
        .disabled-notification {
            position: fixed; top: 20px; right: 20px; z-index: 9999;
            background: #ff6b6b; color: white; padding: 12px 20px;
            border-radius: 8px; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            animation: slideInRight 0.3s ease;
        }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .endgame-summary {
            display: none;
            margin-top: 24px;
            padding: 24px;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(26, 32, 44, 0.95) 0%, rgba(17, 24, 39, 0.95) 100%);
            border: 2px solid rgba(99, 102, 241, 0.4);
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
            color: #e2e8f0;
        }

        .endgame-summary.visible {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .endgame-summary h2 {
            margin: 0 0 8px;
            font-size: 1.6em;
            color: #a5b4ff;
        }

        .endgame-summary .summary-subtitle {
            margin: 0 0 16px;
            color: rgba(226, 232, 240, 0.75);
        }

        .endgame-summary .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .endgame-summary .summary-card {
            background: rgba(79, 70, 229, 0.12);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .endgame-summary .summary-value {
            font-size: 1.8em;
            font-weight: 700;
            color: #c7d2fe;
        }

        .endgame-summary .summary-label {
            font-size: 0.9em;
            color: rgba(226, 232, 240, 0.75);
            margin-top: 6px;
        }

        .endgame-summary .summary-section {
            margin-top: 20px;
        }

        .endgame-summary .summary-section h3 {
            margin: 0 0 12px;
            font-size: 1.1em;
            color: #c7d2fe;
        }

        .endgame-summary .summary-text {
            background: rgba(79, 70, 229, 0.1);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 10px;
            padding: 14px;
            line-height: 1.6;
        }

        .endgame-summary .summary-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 24px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .endgame-summary .summary-winner {
            margin-top: 8px;
            font-weight: 600;
            color: #fbbf24;
        }

        .conversation-callout {
            margin-top: 12px;
            padding: 10px 14px;
            border-radius: 10px;
            background: rgba(74, 222, 128, 0.12);
            border: 1px solid rgba(74, 222, 128, 0.35);
            color: #bbf7d0;
            font-weight: 600;
            display: none;
        }

        .conversation-callout.visible {
            display: block;
            animation: fadeIn 0.25s ease;
        }
    </style>
</head>
<body class="experimental-ui">
    <div class="app-wrapper personality-theme" id="app-root">
        <div class="app-content">
            <header class="app-header">
                <div class="app-title-group">
                    <h1 class="app-title">Paper Scissor Stone ML Arena</h1>
                    <p class="app-subtitle">Challenge adaptive AI opponents with live analytics, coaching intelligence, and cinematic battle visuals.</p>
                    <div class="badge-deck">
                        <span class="badge">üß† Adaptive ML</span>
                        <span class="badge">üìà Live Analytics</span>
                        <span class="badge">ü§ñ Personality Engine</span>
                        <span class="badge">üèÜ Tournament Ready</span>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="pill-button gradient-success" onclick="saveCurrentReplay()">üíæ Save Current Replay</button>
                    <button class="pill-button gradient-info" onclick="window.open('/replay/dashboard', '_blank')">üé¨ View All Replays</button>
                    <button class="pill-button" onclick="window.open('/developer', '_blank')">üîß Developer Console</button>
                    <button class="pill-button gradient-danger" onclick="window.open('/performance', '_blank')">‚ö° Performance Dashboard</button>
                    <button class="pill-button outline" onclick="testRobotUpdate()">üîß Test Update</button>
                    <button class="pill-button gradient-danger" onclick="resetGame()">üîÑ Reset Game</button>
                    <button class="pill-button gradient-info" onclick="exportAnalytics()">üìä Export Data</button>
                    <button class="pill-button gradient-success disabled-tournament" disabled onclick="showDisabledMessage('Tournament feature is temporarily disabled for maintenance')">üèÜ Tournament</button>
                    <button class="pill-button outline" onclick="showDeveloperMetrics()">üîß Developer Metrics</button>
                    <button class="pill-button gradient-primary" onclick="window.open('/ai_coach_demo', '_blank')">ü§ñ AI Coach Demo</button>
                </div>
            </header>

            <div class="page-structure">
                <section class="panel top-intel" id="top-intel">
                    <nav class="mode-switcher top-switcher" aria-label="Summary Switcher">
                        <button class="mode-tab" data-mode="top-overview">üìä Overview</button>
                        <button class="mode-tab active" data-mode="top-controls">üéõÔ∏è Controls</button>
                    </nav>
                    <div class="mode-panels top-panels">
                        <div class="mode-panel" data-mode="top-overview">
                            <div class="hero-summary-grid">
                                <div class="hero-summary-block hero-strategy">
                                    <div class="summary-heading">
                                        <h2 class="panel-title">Adaptive Strategy Monitor</h2>
                                        <span class="panel-subtitle">Live look at how the AI is approaching the next round.</span>
                                    </div>
                                    <div class="status-value">
                                        Current Strategy: <span id="current-strategy-text">Analyzing...</span>
                                    </div>
                                </div>
                                <div class="hero-summary-block hero-scoreboard">
                                    <div class="summary-heading">
                                        <h2 class="panel-title">Match Scoreboard</h2>
                                        <span class="panel-subtitle">Keep tabs on the overall duel momentum.</span>
                                    </div>
                                    <div class="stat-grid">
                                        <div class="stat-card">
                                            <h4>Rounds</h4>
                                            <div id="rounds" class="stat-value">{{ round }}</div>
                                        </div>
                                        <div class="stat-card">
                                            <h4>Your Wins</h4>
                                            <div id="human-wins" class="stat-value">{{ stats.human_win }}</div>
                                        </div>
                                        <div class="stat-card">
                                            <h4>Computer Wins</h4>
                                            <div id="robot-wins" class="stat-value">{{ stats.robot_win }}</div>
                                        </div>
                                        <div class="stat-card">
                                            <h4>Ties</h4>
                                            <div id="ties" class="stat-value">{{ stats.tie }}</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="hero-summary-block hero-alerts">
                                    <div class="summary-heading">
                                        <h2 class="panel-title">Live Alerts</h2>
                                        <span class="panel-subtitle">We flag pattern shifts and strategy cues for you.</span>
                                    </div>
                                    <div id="alert-feed" class="alert-feed">
                                        <div class="alert-chip muted">Play a round to populate insights.</div>
                                    </div>
                                </div>
                            </div>
                            <div class="overview-insights">
                                <div class="overview-section">
                                    <h3 class="overview-title">Full Game Snapshot</h3>
                                    <div class="overview-grid">
                                        <div class="overview-card">
                                            <span class="label">Rounds</span>
                                            <span class="value" id="overview-total-rounds">0</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Human Win Rate</span>
                                            <span class="value" id="overview-human-winrate">--%</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Robot Win Rate</span>
                                            <span class="value" id="overview-robot-winrate">--%</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Tie Rate</span>
                                            <span class="value" id="overview-tie-rate">--%</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Longest Your Streak</span>
                                            <span class="value" id="overview-longest-human">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Longest Robot Streak</span>
                                            <span class="value" id="overview-longest-robot">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Most Common Move</span>
                                            <span class="value" id="overview-common-move">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">AI Prediction Accuracy</span>
                                            <span class="value" id="overview-ai-accuracy">--%</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="overview-section">
                                    <h3 class="overview-title">Recent Momentum (Last 10)</h3>
                                    <div class="overview-grid">
                                        <div class="overview-card">
                                            <span class="label">Recent Win Rate</span>
                                            <span class="value" id="overview-recent-winrate">--%</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Current Streak</span>
                                            <span class="value" id="overview-current-streak">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Recent Bias</span>
                                            <span class="value" id="overview-recent-move">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Score Differential</span>
                                            <span class="value" id="overview-score-diff">0</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Pattern Changes</span>
                                            <span class="value" id="overview-pattern-changes">0</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">AI Confidence</span>
                                            <span class="value" id="overview-ai-confidence">--%</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="overview-section">
                                    <h3 class="overview-title">Strategic Intelligence</h3>
                                    <div class="overview-grid">
                                        <div class="overview-card wide">
                                            <span class="label">Predictability Score</span>
                                            <span class="value" id="overview-predictability">--</span>
                                            <span class="hint">Lower is better for humans</span>
                                        </div>
                                        <div class="overview-card wide">
                                            <span class="label">Adaptation Rate</span>
                                            <span class="value" id="overview-adaptation">--</span>
                                            <span class="hint">How quickly you adjust</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="overview-summary" id="overview-recommendation">Awaiting gameplay data...</div>
                            </div>
                        </div>
                        <div class="mode-panel active" data-mode="top-controls">
                            <div class="control-grid">
                                <div class="control-row">
                                    <div class="select-card">
                                        <label for="difficulty">üéØ AI Difficulty</label>
                                        <select id="difficulty" onchange="setDifficulty()">
                                            <option value="random" selected>Random</option>
                                            <option value="frequency">Frequency</option>
                                            <option value="markov">Markov</option>
                                            <option value="enhanced">Enhanced ML</option>
                                            <option value="lstm">LSTM Neural</option>
                                        </select>
                                    </div>
                                    <div class="select-card">
                                        <label for="strategy">‚öîÔ∏è AI Strategy</label>
                                        <select id="strategy" onchange="setStrategy()">
                                            <option value="balanced" selected>üéØ Balanced</option>
                                            <option value="to_win">üó°Ô∏è To Win (Aggressive)</option>
                                            <option value="not_to_lose">üõ°Ô∏è Not to Lose (Defensive)</option>
                                        </select>
                                    </div>
                                    <div class="select-card">
                                        <label for="personality">ü§ñ AI Personality</label>
                                        <select id="personality" onchange="setPersonality()">
                                            <option value="neutral" selected>üòê Neutral</option>
                                            <option value="berserker">‚öîÔ∏è The Berserker (Ultra Aggressive)</option>
                                            <option value="guardian">üõ°Ô∏è The Guardian (Defensive Expert)</option>
                                            <option value="chameleon">ü¶é The Chameleon (Adaptive)</option>
                                            <option value="professor">üî¨ The Professor (Analytical)</option>
                                            <option value="wildcard">üÉè The Wildcard (Unpredictable)</option>
                                            <option value="mirror">ü™û The Mirror (Mimicking)</option>
                                        </select>
                                    </div>
                                    <div class="select-card">
                                        <label for="game-length">‚è±Ô∏è Game Length</label>
                                        <select id="game-length" onchange="setGameLength()">
                                            <option value="25" selected>25 Moves</option>
                                            <option value="50">50 Moves</option>
                                            <option value="100">100 Moves</option>
                                            <option value="250">250 Moves</option>
                                            <option value="500">500 Moves</option>
                                            <option value="1000">1000 Moves</option>
                                            <option value="infinite">Infinite</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <!-- Buttons moved to header-actions -->
                            <div id="robot-character-display" class="robot-profile">
                                <div id="robot-avatar" class="robot-avatar">
                                    <span class="avatar-emoji">ü§ñ</span>
                                    <div id="strategy-symbol" class="strategy-icon">‚öîÔ∏è</div>
                                </div>
                                <div class="robot-meta">
                                    <div class="meta-title"><span id="robot-name">Standard Robot</span></div>
                                    <div class="meta-tags">
                                        <span class="tag">Difficulty: <span id="robot-difficulty">Easy</span></span>
                                        <span class="tag">Strategy: <span id="robot-strategy">Random</span></span>
                                        <span class="tag">Personality: <span id="robot-personality">Balanced</span></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <div class="bottom-grid">
                    <section class="panel combat-cluster" id="battle-console">
                        <div class="combat-stack">
                            <div class="conversation-wrapper">
                                <div id="robot-conversation" class="conversation-panel">
                                    <div class="conversation-heading">
                                        <h3>AI Comms Channel</h3>
                                        <span>Live banter from your opponent.</span>
                                    </div>
                                    <div class="conversation-body">
                                        <div id="conversation-avatar" class="conversation-avatar">ü§ñ</div>
                                        <div class="conversation-content">
                                            <div class="speech-bubble">
                                                <div id="robot-speech">"Ready for battle? Let's see what you've got!"</div>
                                                <span class="speech-tail"></span>
                                            </div>
                                        <div class="conversation-meta">
                                            <span id="robot-mood">üòé Confident</span>
                                        </div>
                                        <div id="player-performance-callout" class="conversation-callout" aria-live="polite"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="move-display-window" class="move-display">
                                <div id="human-move-display" class="move-display-card">
                                    <h3 class="move-title">You</h3>
                                    <div class="move-visual">
                                        <img id="human-move-img" src="/static/paper.png" alt="Your Move" style="display: none;">
                                        <span id="human-move-text">Choose your move</span>
                                    </div>
                                </div>
                                <div id="robot-move-display" class="move-display-card">
                                    <h3 class="move-title">Robot</h3>
                                    <div class="move-visual">
                                        <img id="robot-move-img" src="/static/paper.png" alt="Robot Move" style="display: none;">
                                        <span id="robot-move-text">Thinking...</span>
                                    </div>
                                </div>
                                <div class="move-display-card vs-card">
                                    <div id="round-result" class="round-result" style="display: none;">Round Result</div>
                                </div>
                            </div>
                            <div id="result" class="result-banner">
                                Press buttons or use A, W, D keys to play!
                            </div>
                            <div id="endgame-summary-panel" class="endgame-summary" aria-live="polite"></div>
                            <div class="move-pad">
                                <button type="button" id="move-paper" class="move-btn" onclick="submitMove('paper')">Paper (P)</button>
                                <button type="button" id="move-stone" class="move-btn" onclick="submitMove('stone')">Rock (R)</button>
                                <button type="button" id="move-scissor" class="move-btn" onclick="submitMove('scissor')">Scissor (S)</button>
                            </div>
                        </div>
                    </section>

                    <section class="panel intel-cluster">
                        <nav class="mode-switcher intel-switcher" aria-label="Insight Switcher">
                            <button class="mode-tab active" data-mode="pattern">üîÑ Pattern View</button>
                            <button class="mode-tab" data-mode="analytics">üìà Analytics View</button>
                            <button class="mode-tab" data-mode="coach">üéì Coach View</button>
                        </nav>
                        <div class="mode-panels intel-panels">
                            <div class="mode-panel active" data-mode="pattern">
                                <section class="panel pattern-overview">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">Pattern Awareness</h2>
                                        <span class="panel-subtitle">Spot the human tendencies the AI is tracking.</span>
                                    </div>
                                    <div class="pattern-metric-grid">
                                        <div class="analytics-card">
                                            <h4>üéØ Predictability Score</h4>
                                            <div id="predictability-score" class="metric-value">--</div>
                                            <div id="predictability-status" class="metric-caption">Analyzing...</div>
                                        </div>
                                        <div class="analytics-card">
                                            <h4>üèÜ Win Rate Trend</h4>
                                            <div id="win-rate-trend" class="metric-value">--</div>
                                            <div id="trend-status" class="metric-caption">Recent 10 games</div>
                                        </div>
                                        <div class="analytics-card">
                                            <h4>üîÑ Strategy Changes</h4>
                                            <div id="strategy-changes-count" class="metric-value">--</div>
                                            <div id="changes-status" class="metric-caption">Adaptability</div>
                                        </div>
                                        <div class="analytics-card">
                                            <h4>üé≤ Randomness Level</h4>
                                            <div id="randomness-level" class="metric-value">--</div>
                                            <div id="randomness-status" class="metric-caption">Unpredictability</div>
                                        </div>
                                    </div>
                                </section>
                                <section class="panel move-distribution-panel">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">üìà Move Distribution Analysis</h2>
                                        <span class="panel-subtitle">Where your habits are clustering right now.</span>
                                    </div>
                                    <div class="distribution-grid">
                                        <div class="move-bar">
                                            <div class="move-label">Paper (P)</div>
                                            <div class="bar-container">
                                                <div class="bar-fill paper" id="paper-fill"></div>
                                            </div>
                                            <div class="bar-percentage" id="paper-percent">0%</div>
                                        </div>
                                        <div class="move-bar">
                                            <div class="move-label">Rock (R)</div>
                                            <div class="bar-container">
                                                <div class="bar-fill rock" id="rock-fill"></div>
                                            </div>
                                            <div class="bar-percentage" id="rock-percent">0%</div>
                                        </div>
                                        <div class="move-bar">
                                            <div class="move-label">Scissor (S)</div>
                                            <div class="bar-container">
                                                <div class="bar-fill scissor" id="scissor-fill"></div>
                                            </div>
                                            <div class="bar-percentage" id="scissor-percent">0%</div>
                                        </div>
                                    </div>
                                </section>
                                <section class="panel history-panel compact-history">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">Recent History</h2>
                                        <span class="panel-subtitle">Last ten moves at a glance.</span>
                                    </div>
                                    <p><strong>Your moves:</strong> <span id="recent-human">{{ human_history[-10:]|join(', ') }}</span></p>
                                    <p><strong>Computer moves:</strong> <span id="recent-robot">{{ robot_history[-10:]|join(', ') }}</span></p>
                                </section>
                            </div>

                            <div class="mode-panel" data-mode="analytics">
                                <section class="panel analytics-panel">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">Visual Analytics</h2>
                                        <span class="panel-subtitle">Real-time visuals of strategy performance.</span>
                                    </div>
                                    <div class="charts-grid two-column">
                                        <div class="chart-card">
                                            <h4>Move Distribution</h4>
                                            <div id="moveDistributionPercentages" class="chart-percentage-display" style="text-align:center; color:#f8fafc; font-size:1.1em; margin-bottom:4px;"></div>
                                            <canvas id="moveDistributionChart"></canvas>
                                        </div>
                                        <div class="chart-card">
                                            <h4>Win Rate Trend</h4>
                                            <canvas id="winRateTrendChart"></canvas>
                                        </div>
                                        <div class="chart-card">
                                            <h4>Score Differential</h4>
                                            <canvas id="scoreDifferentialChart"></canvas>
                                        </div>
                                        <div class="chart-card">
                                            <h4>Model Performance Metrics</h4>
                                            <canvas id="modelAccuracyChart"></canvas>
                                        </div>
                                    </div>
                                    <div class="chart-card">
                                        <h4>Model Confidence Trends</h4>
                                        <canvas id="confidenceTrendChart"></canvas>
                                    </div>
                                    <div class="chart-card wide">
                                        <h4>ü§ñ Model Prediction Tracking</h4>
                                        <p class="chart-hint">Compare human moves vs robot moves vs optional model predictions (Axis shows S=Scissor, R=Rock, P=Paper)</p>
                                        <div class="prediction-toggle">
                                            <div class="prediction-info">Human Move (always on)</div>
                                            <label class="prediction-option">
                                                <input type="checkbox" data-dataset-index="1">
                                                Robot Move
                                            </label>
                                            <label class="prediction-option">
                                                <input type="checkbox" data-dataset-index="2">
                                                Frequency Prediction
                                            </label>
                                            <label class="prediction-option">
                                                <input type="checkbox" data-dataset-index="3">
                                                Markov Prediction
                                            </label>
                                            <label class="prediction-option">
                                                <input type="checkbox" data-dataset-index="4">
                                                Enhanced Prediction
                                            </label>
                                            <label class="prediction-option">
                                                <input type="checkbox" data-dataset-index="5">
                                                LSTM Prediction
                                            </label>
                                            <label class="prediction-option">
                                                <input type="checkbox" id="prediction-range-toggle">
                                                Show Full History
                                            </label>
                                        </div>
                                        <canvas id="modelPredictionChart"></canvas>
                                    </div>
                                </section>
                                <section class="panel analytics-quick">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">Performance Snapshots</h2>
                                        <span class="panel-subtitle">Key metrics from the analytical models.</span>
                                    </div>
                                    <div class="metric-board">
                                        <h5 class="metric-title">üìä Model Performance Metrics</h5>
                                        <div id="modelMetricsTable" class="metric-grid"></div>
                                        <div class="recommended-strategy" id="recommendedStrategy">Analyzing performance...</div>
                                    </div>
                                </section>
                                <section class="panel analytics-actions">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">Analytics Actions</h2>
                                        <span class="panel-subtitle">Take snapshots or refresh the data stream.</span>
                                    </div>
                                    <div class="advanced-actions">
                                        <button class="btn primary" onclick="exportAnalytics('json')">üìÑ Export JSON Report</button>
                                    </div>
                                </section>
                            </div>

                            <div class="mode-panel" data-mode="coach">
                                <section class="panel coach-panel">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">üéì AI Coach</h2>
                                        <span class="panel-subtitle">Personalized insights and experiments.</span>
                                    </div>
                                    <div class="secondary-panel">
                                        <div class="panel coach-card">
                                            <div class="panel-heading">
                                                <h4 class="panel-title">üí° Your Strategy Tips</h4>
                                                <div style="display: flex; align-items: center; gap: 10px;">
                                                    <select id="llm-type-selector" onchange="updateLLMType()">
                                                        <option value="mock">MockLLM (Fast)</option>
                                                        <option value="trained">Trained Model (Our AI)</option>
                                                        <option value="real">Real LLM (Advanced)</option>
                                                    </select>
                                                    <button class="btn primary" onclick="refreshCoachingTips()">üîÑ Get New Tips</button>
                                                </div>
                                            </div>
                                            <div id="coaching-tips-list" class="coach-content">
                                                <p>Play a few rounds to get personalized coaching tips!</p>
                                            </div>
                                        </div>
                                        <div class="panel coach-card">
                                            <div class="panel-heading">
                                                <h4 class="panel-title">üß™ Experiments to Try</h4>
                                            </div>
                                            <div id="experiments-list" class="coach-content">
                                                <p>Suggested strategies will appear here!</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div id="insights-summary" class="panel insights-panel" style="display: none;">
                                        <div class="panel-heading">
                                            <h4 class="panel-title">üìä Pattern Analysis</h4>
                                        </div>
                                        <div id="insights-content" class="coach-content"></div>
                                    </div>
                                </section>
                            </div>
                        </div>
                    </section>
                </div>
            </div>
        </div>
    </div>

    <div id="tournamentModal" class="tournament-modal" style="display: none;">
        <div class="tournament-content">
            <div class="tournament-header">
                <h2>üèÜ Tournament Dashboard</h2>
                <button class="btn destructive" onclick="document.getElementById('tournamentModal').style.display='none'">‚úï</button>
            </div>
            <div class="tournament-grid">
                <div class="tournament-card">
                    <h3>üìä Tournament Stats</h3>
                    <div class="tournament-stats">
                        <div class="stat-block">
                            <div id="totalPlayers" class="stat-value">0</div>
                            <div class="stat-label">Total Players</div>
                        </div>
                        <div class="stat-block">
                            <div id="totalMatches" class="stat-value">0</div>
                            <div class="stat-label">Completed Matches</div>
                        </div>
                    </div>
                </div>
                <div class="tournament-card">
                    <h3>‚ûï Create Player</h3>
                    <div class="create-player">
                        <input type="text" id="newPlayerName" placeholder="Enter player name">
                        <button class="btn primary" onclick="createTournamentPlayer()">Create</button>
                    </div>
                </div>
            </div>
            <div class="tournament-grid">
                <div class="tournament-card">
                    <h3>üèÖ Leaderboard</h3>
                    <div id="leaderboard" class="leaderboard"></div>
                </div>
                <div class="tournament-card">
                    <h3>‚öîÔ∏è Quick Match</h3>
                    <p>Select two players for a quick match</p>
                    <div class="quick-match">
                        <input type="text" id="player1Name" placeholder="Player 1 name">
                        <input type="text" id="player2Name" placeholder="Player 2 name">
                    </div>
                    <button class="btn primary" onclick="createQuickMatch()">üéÆ Start Match</button>
                </div>
            </div>
        </div>
    </div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        console.log('Main page script loading...');
        
        // Global variables (will be updated from dropdown values on page load)
    let currentDifficulty = 'random';  // Default fallback (mildest)
    let currentStrategy = 'balanced';  // Default fallback (mildest)
    let currentPersonality = 'neutral';  // Default fallback (mildest)
        
        // Chart variables
        let moveDistributionChart = null;
        let winRateTrendChart = null;
        let scoreDifferentialChart = null;
        let modelPredictionChart = null;
        let modelAccuracyChart = null;
        let confidenceTrendChart = null;

        let currentGameLimit = null; // Will be set from dropdown on page load
        let isGameFrozen = false;
        let endgameSummaryShown = false;
        let defaultResultMessage = '';
        
        // Initialize charts when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing charts...');
            
            // Get actual dropdown values instead of relying on template variables
            currentDifficulty = document.getElementById('difficulty').value;
            currentStrategy = document.getElementById('strategy').value;
            currentPersonality = document.getElementById('personality').value;
            
            console.log('Initial dropdown values:', {
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality
            });
            
            setTimeout(initializeCharts, 100); // Small delay to ensure DOM is ready
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            setTimeout(() => updateRobotConversation(currentPersonality, 'start'), 200);
            setupModeTabs();

            const resultElement = document.getElementById('result');
            if (resultElement) {
                defaultResultMessage = resultElement.textContent;
            }
            setGameLength();
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            console.log('Key pressed:', e.key);
            if (e.key === 'p' || e.key === 'P') submitMove('paper');
            if (e.key === 'r' || e.key === 'R') submitMove('stone'); // Rock = Stone
            if (e.key === 's' || e.key === 'S') submitMove('scissor');
        });
        

        function highlightMatches() {
            if (!modelPredictionChart) return;
            const humanDataset = modelPredictionChart.data.datasets[0];
            const activeDatasets = modelPredictionChart.data.datasets
                .map((dataset, index) => ({ dataset, index }))
                .filter(({ dataset, index }) => index !== 0 && !dataset.hidden);

            modelPredictionChart.data.datasets.forEach((dataset, idx) => {
                if (idx === 0) {
                    dataset.pointBackgroundColor = dataset.data.map(() => '#FF6384');
                    dataset.pointRadius = dataset.data.map(() => 4);
                } else {
                    dataset.pointRadius = dataset.data.map(value => (dataset.hidden || value === null ? 0 : 3));
                    dataset.pointBackgroundColor = dataset.data.map(() => dataset.borderColor);
                }
            });

            if (activeDatasets.length === 1) {
                const { dataset: activeDataset } = activeDatasets[0];
                activeDataset.pointRadius = activeDataset.data.map((value, idx) => {
                    const humanValue = humanDataset.data[idx];
                    return value !== null && value === humanValue ? 6 : 3;
                });
                activeDataset.pointBackgroundColor = activeDataset.data.map((value, idx) => {
                    const humanValue = humanDataset.data[idx];
                    return value !== null && value === humanValue ? '#4ade80' : activeDataset.borderColor;
                });
            }
        }

        function initializePredictionToggle() {
            const toggleContainer = document.querySelector('.prediction-toggle');
            if (!toggleContainer) return;
            const inputs = toggleContainer.querySelectorAll('input[data-dataset-index]');
            const showAllToggle = document.getElementById('prediction-range-toggle');

            inputs.forEach(input => {
                const idx = parseInt(input.dataset.datasetIndex, 10);
                if (!Number.isNaN(idx) && modelPredictionChart && modelPredictionChart.data.datasets[idx]) {
                    input.checked = !modelPredictionChart.data.datasets[idx].hidden;
                }

                input.addEventListener('change', () => {
                    if (!modelPredictionChart) return;
                    const index = parseInt(input.dataset.datasetIndex, 10);
                    if (Number.isNaN(index) || !modelPredictionChart.data.datasets[index]) return;
                    modelPredictionChart.data.datasets[index].hidden = !input.checked;
                    highlightMatches();
                    modelPredictionChart.update();
                });
            });

            if (showAllToggle) {
                showAllToggle.checked = false;
                showAllToggle.addEventListener('change', () => {
                    if (lastChartData) {
                        const insights = deriveGameInsights(lastChartData);
                        updateOverviewPanel(insights);
                        updateCharts(lastChartData, insights);
                    }
                });
            }

            if (modelPredictionChart) {
                highlightMatches();
            }
        }

        function parseGameLimit(value) {
            return value === 'infinite' ? Infinity : parseInt(value, 10);
        }

        function setMoveButtonsDisabled(disabled) {
            document.querySelectorAll('.move-btn').forEach(btn => {
                btn.disabled = disabled;
                btn.classList.toggle('is-disabled', disabled);
            });
        }

        function setGameLength() {
            const select = document.getElementById('game-length');
            if (!select) return;
            currentGameLimit = parseGameLimit(select.value);
            if (!Number.isFinite(currentGameLimit)) {
                currentGameLimit = Infinity;
            }

            if (isGameFrozen && lastChartData && (lastChartData.round || 0) < currentGameLimit) {
                isGameFrozen = false;
                setMoveButtonsDisabled(false);
                const resultElement = document.getElementById('result');
                if (resultElement && defaultResultMessage) {
                    resultElement.textContent = defaultResultMessage;
                }
                const summaryPanel = document.getElementById('endgame-summary-panel');
                if (summaryPanel) {
                    summaryPanel.classList.remove('visible');
                    summaryPanel.innerHTML = '';
                }
                endgameSummaryShown = false;
            }

            if (lastChartData) {
                const insights = deriveGameInsights(lastChartData);
                updateOverviewPanel(insights);
                updateCharts(lastChartData, insights);
            }
        }

        function freezeGame(data, insights) {
            if (isGameFrozen) return;
            isGameFrozen = true;
            setMoveButtonsDisabled(true);
            renderPostGameSummary(insights);
            presentGameSummaryModal(insights);
        }

        function renderPostGameSummary(insights) {
            if (!insights) return;
            const resultElement = document.getElementById('result');
            if (!resultElement) return;
            const humanWins = insights.humanWins ?? 0;
            const robotWins = insights.robotWins ?? 0;
            const ties = insights.ties ?? 0;
            const overallWinRate = (insights.humanWinRate ?? 0).toFixed(1);
            const recentWinRate = (insights.recentHumanWinRate ?? 0).toFixed(1);
            const longestHumanStreak = insights.longestHumanStreak ?? 0;
            const longestRobotStreak = insights.longestRobotStreak ?? 0;
            const commonMove = insights.mostCommonMove ?? '‚Äî';
            const commonMovePct = (insights.mostCommonMovePercent ?? 0).toFixed(1);
            const recommendation = insights.recommendation || 'Keep experimenting with new patterns to maintain unpredictability.';
            const summaryLines = [
                `Final score: You ${humanWins} - Robot ${robotWins} (ties ${ties}).`,
                `Overall win rate: ${overallWinRate}% (last 10 rounds: ${recentWinRate}%).`,
                `Longest streaks ‚Äî You: ${longestHumanStreak} | Robot: ${longestRobotStreak}.`,
                `Most common move: ${commonMove} (${commonMovePct}%).`,
                recommendation
            ];
            resultElement.innerHTML = '<h3>Match Complete</h3><p>' + summaryLines.join('<br>') + '</p>';
        }

        function determineWinner(humanMove, robotMove) {
            if (!humanMove || !robotMove) return 'unknown';
            if (humanMove === robotMove) return 'tie';
            const normalizedHuman = humanMove.toLowerCase();
            const normalizedRobot = robotMove.toLowerCase();
            const winMap = { 'rock': 'scissor', 'stone': 'scissor', 'scissor': 'paper', 'paper': 'rock' };
            return winMap[normalizedHuman] === normalizedRobot ? 'human' : 'robot';
        }

        function computeRollingAccuracy(predictions, actual) {
            const series = [];
            let considered = 0;
            let correct = 0;
            for (let i = 0; i < actual.length; i++) {
                const target = actual[i];
                const guess = predictions[i];
                if (target !== null && target !== undefined) {
                    if (guess !== null && guess !== undefined) {
                        considered += 1;
                        if (guess === target) correct += 1;
                    }
                }
                const value = considered > 0 ? (correct / considered) * 100 : 0;
                series.push(value);
            }
            return series;
        }

        function formatMoveName(move) {
            if (!move || move === 'unknown') return '‚Äî';
            const normalized = move.toLowerCase();
            if (normalized === 'stone') return 'Rock';
            return normalized.charAt(0).toUpperCase() + normalized.slice(1);
        }

        function deriveGameInsights(data) {
            const stats = data.stats || {};
            const humanHistory = data.human_history ? data.human_history.slice() : [];
            const robotHistory = data.robot_history ? data.robot_history.slice() : [];
            const toNumber = (move) => {
                if (!move) return null;
                const normalized = move.toLowerCase();
                if (normalized === 'paper') return 2;
                if (normalized === 'rock' || normalized === 'stone') return 1;
                if (normalized === 'scissor') return 0;
                return null;
            };

            const humanNumeric = humanHistory.map(toNumber);
            const winners = [];
            let scoreDiff = 0;
            const scoreDifferentialSeries = [];
            let bestHumanStreak = 0;
            let bestRobotStreak = 0;
            let streakOwner = 'tie';
            let streakLength = 0;

            humanHistory.forEach((humanMove, index) => {
                const robotMove = robotHistory[index];
                const winner = determineWinner(humanMove, robotMove);
                winners.push(winner);
                if (winner === 'human') scoreDiff += 1;
                if (winner === 'robot') scoreDiff -= 1;
                scoreDifferentialSeries.push(scoreDiff);

                if (winner === streakOwner) {
                    streakLength += 1;
                } else {
                    streakOwner = winner;
                    streakLength = 1;
                }

                if (winner === 'human') {
                    if (streakLength > bestHumanStreak) bestHumanStreak = streakLength;
                } else if (winner === 'robot') {
                    if (streakLength > bestRobotStreak) bestRobotStreak = streakLength;
                }
            });

            const moveCounts = humanHistory.reduce((acc, move) => {
                if (!move) return acc;
                const normalized = move.toLowerCase();
                acc[normalized] = (acc[normalized] || 0) + 1;
                return acc;
            }, {});
            const totalRounds = data.round || humanHistory.length || 0;
            let mostCommonMove = '‚Äî';
            let mostCommonMovePercent = 0;
            Object.entries(moveCounts).forEach(([move, count]) => {
                const percent = totalRounds > 0 ? (count / totalRounds) * 100 : 0;
                if (percent > mostCommonMovePercent) {
                    mostCommonMovePercent = percent;
                    mostCommonMove = formatMoveName(move);
                }
            });

            const padPredictions = (predictions) => {
                const copy = Array.isArray(predictions) ? predictions.map(toNumber) : [];
                while (copy.length < humanNumeric.length) copy.push(null);
                return copy;
            };

            const frequencyPreds = padPredictions(data.model_predictions_history?.frequency || []);
            const markovPreds = padPredictions(data.model_predictions_history?.markov || []);
            const enhancedPreds = padPredictions(data.model_predictions_history?.enhanced || []);
            const lstmPreds = padPredictions(data.model_predictions_history?.lstm || []);

            const accuracySeries = {
                frequency: computeRollingAccuracy(frequencyPreds, humanNumeric),
                markov: computeRollingAccuracy(markovPreds, humanNumeric),
                enhanced: computeRollingAccuracy(enhancedPreds, humanNumeric),
                lstm: computeRollingAccuracy(lstmPreds, humanNumeric)
            };

            const recentSample = winners.slice(-10);
            const humanWins = stats.human_win || 0;
            const robotWins = stats.robot_win || 0;
            const ties = stats.tie || 0;
            const total = humanWins + robotWins + ties;
            const humanWinRate = total > 0 ? (humanWins / total) * 100 : 0;
            const robotWinRate = total > 0 ? (robotWins / total) * 100 : 0;
            const tieRate = total > 0 ? (ties / total) * 100 : 0;

            const recentHumanWins = recentSample.filter(w => w === 'human').length;
            const recentRobotWins = recentSample.filter(w => w === 'robot').length;
            const recentTotal = recentSample.length || 1;
            const recentHumanWinRate = (recentHumanWins / recentTotal) * 100;
            const recentRobotWinRate = (recentRobotWins / recentTotal) * 100;

            let currentStreakOwner = 'tie';
            let currentStreakLength = 0;
            for (let i = winners.length - 1; i >= 0; i--) {
                const w = winners[i];
                if (w === 'unknown' || w === 'tie') break;
                if (currentStreakOwner === 'tie') {
                    currentStreakOwner = w;
                    currentStreakLength = 1;
                } else if (w === currentStreakOwner) {
                    currentStreakLength += 1;
                } else {
                    break;
                }
            }
            if (currentStreakOwner === 'tie') {
                currentStreakLength = 0;
            }

            const recentMoves = humanHistory.slice(-10);
            const recentCounts = recentMoves.reduce((acc, move) => {
                if (!move) return acc;
                const normalized = move.toLowerCase();
                acc[normalized] = (acc[normalized] || 0) + 1;
                return acc;
            }, {});
            let recentBiasMove = '‚Äî';
            let recentBiasPercent = 0;
            Object.entries(recentCounts).forEach(([move, count]) => {
                const percent = (count / (recentMoves.length || 1)) * 100;
                if (percent > recentBiasPercent) {
                    recentBiasPercent = percent;
                    recentBiasMove = formatMoveName(move);
                }
            });

            let recommendation = 'Keep monitoring the robot‚Äôs shifts and respond with quick pattern changes.';
            if (recentBiasPercent > 55) {
                recommendation = 'Your play leans heavily on ' + recentBiasMove + '. Mix in other moves to stay unpredictable.';
            } else if (recentHumanWinRate < 40) {
                recommendation = 'Robot momentum is building. Consider switching to the move that counters its recent streak.';
            } else if (humanWinRate > 60) {
                recommendation = 'Great control! Maintain variation to protect your edge.';
            }

            return {
                totalRounds,
                humanWins,
                robotWins,
                ties,
                humanWinRate,
                robotWinRate,
                tieRate,
                mostCommonMove,
                mostCommonMovePercent,
                scoreDifferentialSeries,
                accuracySeries,
                recentHumanWinRate,
                recentRobotWinRate,
                recentBiasMove,
                recentBiasPercent,
                currentStreakOwner,
                currentStreakLength,
                longestHumanStreak: bestHumanStreak,
                longestRobotStreak: bestRobotStreak,
                winners,
                humanNumeric,
                frequencyPreds,
                markovPreds,
                enhancedPreds,
                lstmPreds,
                recommendation,
                moveVariance: calculateMoveVariance(humanHistory),
                patternChanges: calculatePatternChanges(humanHistory),
                aiAccuracy: total > 0 ? (robotWins / total * 100) : 0,
                aiConfidence: data.difficulty === 'lstm' ? 85 : 
                             data.difficulty === 'enhanced' ? 70 : 
                             data.difficulty === 'markov' ? 60 : 
                             data.difficulty === 'frequency' ? 45 : 33
            };
        }

        // Helper functions for Strategic Intelligence metrics
        function calculateMoveVariance(moveHistory) {
            if (!moveHistory || moveHistory.length < 3) return 0;
            
            const moveCounts = { paper: 0, stone: 0, scissor: 0 };
            moveHistory.forEach(move => {
                const normalized = move ? move.toLowerCase() : '';
                if (moveCounts.hasOwnProperty(normalized)) {
                    moveCounts[normalized]++;
                }
            });
            
            const total = moveHistory.length;
            const expectedFreq = total / 3; // Perfectly random would be 33.33% each
            const variance = Object.values(moveCounts).reduce((sum, count) => {
                return sum + Math.pow(count - expectedFreq, 2);
            }, 0) / 3;
            
            // Convert to 0-100 scale (higher = more predictable)
            return Math.min(100, (variance / expectedFreq) * 50);
        }

        function calculatePatternChanges(moveHistory) {
            if (!moveHistory || moveHistory.length < 5) return 0;
            
            let changes = 0;
            let consecutiveCount = 1;
            
            for (let i = 1; i < moveHistory.length; i++) {
                if (moveHistory[i] === moveHistory[i-1]) {
                    consecutiveCount++;
                } else {
                    if (consecutiveCount >= 2) changes++; // Pattern break detected
                    consecutiveCount = 1;
                }
            }
            
            // Calculate adaptation rate (higher = more adaptive)
            const totalPossibleChanges = Math.max(1, moveHistory.length - 1);
            return Math.min(100, (changes / totalPossibleChanges) * 200);
        }

        function updateOverviewPanel(insights) {
            document.getElementById('overview-total-rounds').textContent = insights.totalRounds;
            document.getElementById('overview-human-winrate').textContent = insights.humanWinRate.toFixed(1) + '%';
            document.getElementById('overview-robot-winrate').textContent = insights.robotWinRate.toFixed(1) + '%';
            document.getElementById('overview-tie-rate').textContent = insights.tieRate.toFixed(1) + '%';
            document.getElementById('overview-longest-human').textContent = insights.longestHumanStreak || 0;
            document.getElementById('overview-longest-robot').textContent = insights.longestRobotStreak || 0;
            document.getElementById('overview-common-move').textContent = insights.mostCommonMove;
            document.getElementById('overview-recent-winrate').textContent = insights.recentHumanWinRate.toFixed(1) + '%';
            const streakLabel = insights.currentStreakLength > 0 ? ((insights.currentStreakOwner === 'human' ? 'Your ' : 'Robot ') + insights.currentStreakLength + ' streak') : 'No streak';
            document.getElementById('overview-current-streak').textContent = streakLabel;
            document.getElementById('overview-recent-move').textContent = insights.recentBiasMove !== '‚Äî' ? insights.recentBiasMove + ' (' + insights.recentBiasPercent.toFixed(1) + '%)' : '‚Äî';
            const scoreDiff = insights.humanWins - insights.robotWins;
            document.getElementById('overview-score-diff').textContent = scoreDiff;
            
            // New metrics for Strategic Intelligence
            document.getElementById('overview-ai-accuracy').textContent = insights.aiAccuracy.toFixed(1) + '%';
            document.getElementById('overview-pattern-changes').textContent = Math.round(insights.patternChanges);
            document.getElementById('overview-ai-confidence').textContent = insights.aiConfidence + '%';
            
            // Calculate predictability (higher moveVariance = more predictable)
            const predictabilityScore = insights.moveVariance || 33.3;
            document.getElementById('overview-predictability').textContent = predictabilityScore.toFixed(1) + '%';
            
            // Calculate adaptation rate (pattern changes)
            const adaptationRate = insights.patternChanges || 0;
            document.getElementById('overview-adaptation').textContent = adaptationRate.toFixed(1) + '%';
            
            document.getElementById('overview-recommendation').textContent = insights.recommendation;
        }



        function setupModeTabs() {
            const switchers = document.querySelectorAll('.mode-switcher');
            switchers.forEach(switcher => {
                const tabs = switcher.querySelectorAll('.mode-tab');
                const panelsContainer = switcher.nextElementSibling && switcher.nextElementSibling.classList.contains('mode-panels')
                    ? switcher.nextElementSibling
                    : null;

                if (!tabs.length || !panelsContainer) return;

                const panels = panelsContainer.querySelectorAll('.mode-panel');
                if (!panels.length) return;

                const activateMode = (mode) => {
                    tabs.forEach(tab => {
                        const isActive = tab.dataset.mode === mode;
                        tab.classList.toggle('active', isActive);
                        tab.setAttribute('aria-pressed', isActive);
                    });
                    panels.forEach(panel => {
                        panel.classList.toggle('active', panel.dataset.mode === mode);
                    });
                };

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => activateMode(tab.dataset.mode));
                });

                const initialTab = switcher.querySelector('.mode-tab.active') || tabs[0];
                if (initialTab) activateMode(initialTab.dataset.mode);
            });
        }

        // Game functions
        function submitMove(move) {
            if (isGameFrozen) return;
            console.log('submitMove called with:', move);
            
            // Reset the battle arena for new round
            resetMoveDisplay();
            
            const payload = {
                move: move,
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality,
                game_limit: Number.isFinite(currentGameLimit) ? currentGameLimit : null
            };
            
            console.log('Sending payload:', payload);
            
            fetch('/play', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            })
            .then(res => {
                console.log('Response status:', res.status);
                return res.json();
            })
            .then(data => {
                console.log('Received data:', data);
                updateUI(data);
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = 
                    '<p style="color: red;">Error: ' + error.message + '</p>';
            });
        }
        
        function updateUI(data) {
            if (isGameFrozen) return;
            console.log('Updating UI with:', data);

            // Safely get the last human move
            const lastHumanMove = data.human_history && data.human_history.length > 0 
                ? data.human_history[data.human_history.length-1] 
                : 'unknown';

            // Safely get the robot move
            const robotMove = data.robot_move || 'unknown';

            // Safely get the result
            const result = data.result ? String(data.result) : 'unknown';

            const insights = deriveGameInsights(data);

            // Update result
            document.getElementById('result').innerHTML = 
                '<h3>Round ' + (data.round || 0) + ' Results</h3>' +
                '<p>You played: <strong>' + lastHumanMove.toUpperCase() + '</strong></p>' +
                '<p>Computer played: <strong>' + robotMove.toUpperCase() + '</strong></p>' +
                '<p>Result: <strong>' + result.toUpperCase() + '</strong></p>';
            
            // Update stats safely
            const stats = data.stats || {};
            document.getElementById('rounds').textContent = data.round || 0;
            document.getElementById('human-wins').textContent = stats.human_win || 0;
            document.getElementById('robot-wins').textContent = stats.robot_win || 0;
            document.getElementById('ties').textContent = stats.tie || 0;
            
            // Update recent history safely
            const recentHuman = data.human_history ? data.human_history.slice(-10).join(', ') : '';
            const recentRobot = data.robot_history ? data.robot_history.slice(-10).join(', ') : '';
            document.getElementById('recent-human').textContent = recentHuman;
            document.getElementById('recent-robot').textContent = recentRobot;
            
            // Update strategy display
            if (data.current_strategy) {
                const strategy = String(data.current_strategy);
                document.getElementById('current-strategy-text').textContent = 
                    strategy.charAt(0).toUpperCase() + strategy.slice(1);
            }
            
            // Auto-refresh coaching tips every 5 rounds
            if (data.round && data.round > 0 && data.round % 5 === 0) {
                setTimeout(refreshCoachingTips, 500); // Small delay to ensure data is processed
            }

            // Update analytics dashboard
            updateAnalyticsDashboard(data, insights);

            // Check if game should end based on game length limit
            if (Number.isFinite(currentGameLimit) && data.round >= currentGameLimit) {
                setTimeout(() => {
                    freezeGame(data, insights);
                }, 1000); // Delay to allow move animation to complete
            }

            // Update charts
            updateCharts(data);
            
            // Update move display window
            updateMoveDisplay(lastHumanMove, robotMove, result);
            
            // Update live alert rail
            updateAlertRail(data, result);

            // Update robot conversation based on result
            const conversationEventType = result === 'human' ? 'lose' : result === 'robot' ? 'win' : 'tie';
            setTimeout(() => {
                updateRobotConversation(currentPersonality, conversationEventType, {
                    humanMove: lastHumanMove,
                    robotMove: robotMove,
                    round: data.round,
                    humanWinRate: insights?.humanWinRate,
                    robotWinRate: insights?.robotWinRate,
                    totalRounds: insights?.totalRounds
                });
            }, 800); // Delay to let move display finish
        }
        
        // Move Display Window Functions
        function updateMoveDisplay(humanMove, robotMove, result) {
            // Update human move
            updatePlayerMove('human', humanMove);
            
            // Update robot move with a shorter delay for faster loading
            setTimeout(() => {
                updatePlayerMove('robot', robotMove);
                // Show result immediately after robot move is displayed
                setTimeout(() => {
                    showRoundResult(result, humanMove, robotMove);
                }, 150);
            }, 200);
        }
        
        function updatePlayerMove(player, move) {
            const moveImg = document.getElementById(player + '-move-img');
            const moveText = document.getElementById(player + '-move-text');
            
            if (move && move !== 'unknown') {
                // Set the correct image
                const imageMap = {
                    'stone': '/static/stone.png',
                    'paper': '/static/paper.png',
                    'scissor': '/static/scissor.png'
                };
                
                moveImg.src = imageMap[move.toLowerCase()] || '/static/paper.png';
                moveImg.style.display = 'block';
                moveText.textContent = move.charAt(0).toUpperCase() + move.slice(1);
            } else {
                moveImg.style.display = 'none';
                moveText.textContent = player === 'human' ? 'Choose your move' : 'Thinking...';
            }
        }
        
        function showRoundResult(result, humanMove, robotMove) {
            const resultDiv = document.getElementById('round-result');
            const humanDisplay = document.getElementById('human-move-display');
            const robotDisplay = document.getElementById('robot-move-display');
            
            // Reset borders
            humanDisplay.style.border = '2px solid transparent';
            robotDisplay.style.border = '2px solid transparent';
            
            // Show result and highlight winner
            if (result === 'human') {
                resultDiv.textContent = 'üéâ You Win!';
                resultDiv.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                resultDiv.style.color = 'white';
                humanDisplay.style.border = '2px solid #28a745';
                humanDisplay.style.boxShadow = '0 0 15px rgba(40, 167, 69, 0.4)';
            } else if (result === 'robot') {
                resultDiv.textContent = 'ü§ñ Robot Wins!';
                resultDiv.style.background = 'linear-gradient(135deg, #dc3545, #e83e8c)';
                resultDiv.style.color = 'white';
                robotDisplay.style.border = '2px solid #dc3545';
                robotDisplay.style.boxShadow = '0 0 15px rgba(220, 53, 69, 0.4)';
            } else {
                resultDiv.textContent = 'ü§ù It\'s a Tie!';
                resultDiv.style.background = 'linear-gradient(135deg, #ffc107, #fd7e14)';
                resultDiv.style.color = 'white';
                humanDisplay.style.border = '2px solid #ffc107';
                robotDisplay.style.border = '2px solid #ffc107';
            }
            
            resultDiv.style.display = 'block';
            
            // Don't auto-reset - keep result until next move
        }
        
        function resetMoveDisplay() {
            // Hide images and reset text
            document.getElementById('human-move-img').style.display = 'none';
            document.getElementById('robot-move-img').style.display = 'none';
            document.getElementById('human-move-text').textContent = 'Choose your move';
            document.getElementById('robot-move-text').textContent = 'Thinking...';
            document.getElementById('round-result').style.display = 'none';
            
            // Reset borders and shadows
            const humanDisplay = document.getElementById('human-move-display');
            const robotDisplay = document.getElementById('robot-move-display');
            humanDisplay.style.border = '2px solid transparent';
            robotDisplay.style.border = '2px solid transparent';
            humanDisplay.style.boxShadow = 'none';
            robotDisplay.style.boxShadow = 'none';
        }
        
        // Robot Character Visualization Functions
        function updateRobotCharacter(difficulty, strategy, personality) {
            console.log('updateRobotCharacter called with:', difficulty, strategy, personality);
            updateRobotAvatar(difficulty, personality);
            updateStrategySymbol(strategy);
            updateRobotInfo(difficulty, strategy, personality);
        }
        
        function updateRobotAvatar(difficulty, personality) {
            const avatar = document.getElementById('robot-avatar');
            console.log('updateRobotAvatar - element found:', avatar, 'difficulty:', difficulty, 'personality:', personality);
            
            if (!avatar) {
                console.error('robot-avatar element not found!');
                return;
            }
            
            // Personality character mapping
            const personalityChars = {
                'neutral': 'ü§ñ',
                'berserker': 'üíÄ',
                'guardian': 'üõ°Ô∏è', 
                'chameleon': 'ü¶é',
                'professor': 'üéì',
                'wildcard': 'üÉè',
                'mirror': 'ü™û',
                'balanced': 'ü§ñ'
            };
            
            // Difficulty-based background shading
            const difficultyStyles = {
                'random': {
                    background: 'linear-gradient(135deg, #e8f5e8, #d4edda)',
                    border: '3px solid #28a745'
                },
                'frequency': {
                    background: 'linear-gradient(135deg, #fff3cd, #ffeaa7)',
                    border: '3px solid #ffc107'
                },
                'markov': {
                    background: 'linear-gradient(135deg, #f8d7da, #f5b7b1)',
                    border: '3px solid #dc3545'
                },
                'enhanced': {
                    background: 'linear-gradient(135deg, #f3e5f5, #e1bee7)',
                    border: '3px solid #9c27b0'
                },
                'lstm': {
                    background: 'linear-gradient(135deg, #2c2c2c, #1a1a1a)',
                    border: '3px solid #6f42c1'
                }
            };
            
            // Update character
            const char = personalityChars[personality] || 'ü§ñ';
            console.log('Setting avatar char:', char);
            avatar.textContent = char;
            
            // Update styling
            const style = difficultyStyles[difficulty] || difficultyStyles['random'];
            console.log('Setting avatar style:', style);
            avatar.style.background = style.background;
            avatar.style.border = style.border;
        }
        
        function updateStrategySymbol(strategy) {
            const symbolElement = document.getElementById('strategy-symbol');
            console.log('updateStrategySymbol - element found:', symbolElement, 'strategy:', strategy);
            
            if (!symbolElement) {
                console.error('strategy-symbol element not found!');
                return;
            }
            
            // Strategy symbol mapping
            const strategySymbols = {
                'random': 'üé≤',
                'frequency': 'üìä',
                'pattern': 'üîÑ',
                'markov': 'üß†',
                'minimax': '‚öîÔ∏è',
                'lstm': 'ü§ñ',
                'balanced': '‚öñÔ∏è',
                'to_win': '‚öîÔ∏è',
                'not_to_lose': 'üõ°Ô∏è'
            };
            
            const symbol = strategySymbols[strategy] || '‚öîÔ∏è';
            console.log('Setting symbol to:', symbol);
            symbolElement.textContent = symbol;
        }
        
        function updateRobotInfo(difficulty, strategy, personality) {
            console.log('updateRobotInfo called with:', difficulty, strategy, personality);
            
            // Generate robot name based on personality and difficulty
            const names = {
                'neutral': ['Standard', 'Basic', 'Default', 'Unit'],
                'berserker': ['Destroyer', 'Annihilator', 'Crusher', 'Devastator'],
                'guardian': ['Protector', 'Defender', 'Shield', 'Bulwark'],
                'chameleon': ['Shifter', 'Adapter', 'Morph', 'Mimic'],
                'professor': ['Analyst', 'Scholar', 'Calculator', 'Logic'],
                'wildcard': ['Chaos', 'Random', 'Surprise', 'Wildfire'],
                'mirror': ['Echo', 'Reflection', 'Shadow', 'Copy'],
                'balanced': ['Standard', 'Basic', 'Default', 'Unit']
            };
            
            const nameList = names[personality] || names['neutral'];
            const baseName = nameList[Math.floor(Math.random() * nameList.length)];
            const difficultyPrefix = {
                'random': 'Basic',
                'frequency': 'Junior', 
                'markov': 'Advanced',
                'enhanced': 'Master',
                'lstm': 'Legendary'
            };
            
            const difficultyNames = {
                'random': 'Random',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'enhanced': 'Enhanced ML',
                'lstm': 'LSTM Neural Network'
            };
            
            const strategyNames = {
                'balanced': 'Balanced',
                'to_win': 'Aggressive (To Win)',
                'not_to_lose': 'Defensive (Not to Lose)'
            };
            
            const personalityNames = {
                'neutral': 'Neutral',
                'berserker': 'The Berserker',
                'guardian': 'The Guardian',
                'chameleon': 'The Chameleon',
                'professor': 'The Professor',
                'wildcard': 'The Wildcard',
                'mirror': 'The Mirror'
            };
            
            const robotName = `${difficultyPrefix[difficulty] || 'Basic'} ${baseName}`;
            
            console.log('Updating robot display with:', {
                robotName,
                difficulty: difficultyNames[difficulty] || difficulty,
                strategy: strategyNames[strategy] || strategy,
                personality: personalityNames[personality] || personality
            });
            
            // Update display with proper names
            const robotNameElement = document.getElementById('robot-name');
            const robotDifficultyElement = document.getElementById('robot-difficulty');
            const robotStrategyElement = document.getElementById('robot-strategy');
            const robotPersonalityElement = document.getElementById('robot-personality');
            
            if (robotNameElement) robotNameElement.textContent = robotName;
            if (robotDifficultyElement) robotDifficultyElement.textContent = difficultyNames[difficulty] || difficulty;
            if (robotStrategyElement) robotStrategyElement.textContent = strategyNames[strategy] || strategy;
            if (robotPersonalityElement) robotPersonalityElement.textContent = personalityNames[personality] || personality;
            
            console.log('Robot info updated successfully');
        }
        
        // Robot Conversation System Functions
        function updateRobotConversation(personality, eventType, data = {}) {
            const speechElement = document.getElementById('robot-speech');
            const moodElement = document.getElementById('robot-mood');
            const avatarElement = document.getElementById('conversation-avatar');
            const calloutElement = document.getElementById('player-performance-callout');

            const dialogue = generatePersonalityDialogue(personality, eventType, data);

            // Update speech with typing effect
            typeMessage(speechElement, dialogue.message);

            // Update mood and avatar
            moodElement.textContent = dialogue.mood;
            avatarElement.textContent = dialogue.avatar;

            if (calloutElement) {
                const humanWinRate = typeof data.humanWinRate === 'number' ? data.humanWinRate : null;
                const robotWinRate = typeof data.robotWinRate === 'number' ? data.robotWinRate : null;
                const totalRounds = typeof data.totalRounds === 'number' ? data.totalRounds : 0;

                if (humanWinRate !== null && robotWinRate !== null && totalRounds > 0) {
                    if (humanWinRate > robotWinRate + 0.5) {
                        calloutElement.textContent = `üî• You're ahead with a ${humanWinRate.toFixed(1)}% win rate!`;
                        calloutElement.classList.add('visible');
                    } else if (robotWinRate > humanWinRate + 0.5) {
                        calloutElement.textContent = `‚ö†Ô∏è AI is leading at ${robotWinRate.toFixed(1)}% ‚Äî time to adjust!`;
                        calloutElement.classList.add('visible');
                    } else {
                        calloutElement.textContent = `ü§ù It's a tight contest: ${humanWinRate.toFixed(1)}% vs ${robotWinRate.toFixed(1)}%.`;
                        calloutElement.classList.add('visible');
                    }
                } else {
                    calloutElement.classList.remove('visible');
                    calloutElement.textContent = '';
                }
            }
        }
        
        function generatePersonalityDialogue(personality, eventType, data) {
            const dialogues = {
                'berserker': {
                    'start': {
                        messages: ["CRUSH YOUR ENEMIES!", "No mercy! Let's fight!", "I will dominate this battle!", "Prepare for destruction!"],
                        mood: "üíÄ Bloodthirsty",
                        avatar: "üíÄ"
                    },
                    'win': {
                        messages: ["VICTORY IS MINE!", "Another victim falls!", "Bow before my might!", "Total annihilation!"],
                        mood: "üëπ Triumphant",
                        avatar: "üëπ"
                    },
                    'lose': {
                        messages: ["IMPOSSIBLE! I demand a rematch!", "This rage fuels my power!", "You got lucky this time!", "I will have my revenge!"],
                        mood: "üò° Furious",
                        avatar: "üò°"
                    },
                    'tie': {
                        messages: ["We're equally matched!", "The battle continues!", "Neither yields!", "This proves nothing!"],
                        mood: "‚öîÔ∏è Intense",
                        avatar: "‚öîÔ∏è"
                    }
                },
                'guardian': {
                    'start': {
                        messages: ["I shall protect my honor!", "Defense is the best strategy!", "Stand firm and endure!", "My shield is unbreakable!"],
                        mood: "üõ°Ô∏è Steadfast",
                        avatar: "üõ°Ô∏è"
                    },
                    'win': {
                        messages: ["A well-defended victory!", "Patience and defense prevail!", "Honor is preserved!", "The shield holds strong!"],
                        mood: "üèÜ Honorable",
                        avatar: "üèÜ"
                    },
                    'lose': {
                        messages: ["I fought with honor!", "Sometimes the shield fails...", "Your strategy was admirable!", "I must strengthen my defense!"],
                        mood: "üí™ Resolute",
                        avatar: "üí™"
                    },
                    'tie': {
                        messages: ["A noble stalemate!", "Both warriors show courage!", "Evenly matched defenses!", "Honor to both sides!"],
                        mood: "ü§ù Respectful",
                        avatar: "ü§ù"
                    }
                },
                'chameleon': {
                    'start': {
                        messages: ["Adapting to your style...", "Let me observe your patterns!", "I'll match your energy!", "Time to blend strategies!"],
                        mood: "ü¶é Adaptive",
                        avatar: "ü¶é"
                    },
                    'win': {
                        messages: ["Perfect adaptation!", "I mirrored your weakness!", "Flexibility wins again!", "Change is my strength!"],
                        mood: "üéØ Precise",
                        avatar: "üéØ"
                    },
                    'lose': {
                        messages: ["Interesting... recalibrating!", "Your unpredictability impressed me!", "Time to adapt further!", "Learning from this defeat!"],
                        mood: "üîÑ Evolving",
                        avatar: "üîÑ"
                    },
                    'tie': {
                        messages: ["We adapted to each other!", "Perfectly balanced strategies!", "Mutual adaptation!", "Synchronized thinking!"],
                        mood: "‚öñÔ∏è Balanced",
                        avatar: "‚öñÔ∏è"
                    }
                },
                'professor': {
                    'start': {
                        messages: ["Let's analyze this scientifically!", "Fascinating tactical possibilities!", "Time for logical deduction!", "The data suggests..."],
                        mood: "üî¨ Analytical",
                        avatar: "üéì"
                    },
                    'win': {
                        messages: ["Hypothesis confirmed!", "The calculations were correct!", "Logic prevails once again!", "A predictable outcome!"],
                        mood: "üß† Satisfied",
                        avatar: "üß†"
                    },
                    'lose': {
                        messages: ["Intriguing! An anomaly to study!", "Unexpected variables detected!", "This requires further analysis!", "Statistical outlier noted!"],
                        mood: "ü§î Curious",
                        avatar: "ü§î"
                    },
                    'tie': {
                        messages: ["Statistically balanced outcome!", "Equilibrium achieved!", "Perfect probability distribution!", "Fascinating data point!"],
                        mood: "üìä Logical",
                        avatar: "üìä"
                    }
                },
                'wildcard': {
                    'start': {
                        messages: ["Chaos time! Expect anything!", "Rules? What rules?!", "Let's shake things up!", "Random madness incoming!"],
                        mood: "üÉè Chaotic",
                        avatar: "üÉè"
                    },
                    'win': {
                        messages: ["BOOM! Didn't see that coming!", "Chaos reigns supreme!", "Random victory dance!", "Unpredictability wins!"],
                        mood: "üéâ Ecstatic",
                        avatar: "üéâ"
                    },
                    'lose': {
                        messages: ["Whoops! That was unexpected!", "Plot twist! You got me!", "Chaos works both ways!", "Random defeat... or is it?"],
                        mood: "ü§™ Amused",
                        avatar: "ü§™"
                    },
                    'tie': {
                        messages: ["What are the odds?!", "Chaos creates balance!", "Perfectly random outcome!", "Even randomness has patterns!"],
                        mood: "üé≤ Surprised",
                        avatar: "üé≤"
                    }
                },
                'mirror': {
                    'start': {
                        messages: ["I reflect your every move!", "Mirror mirror on the wall...", "Your style becomes mine!", "Copying... initializing..."],
                        mood: "ü™û Mirroring",
                        avatar: "ü™û"
                    },
                    'win': {
                        messages: ["I became you, but better!", "Perfect reflection achieved!", "Your own moves defeated you!", "Mirror mastery complete!"],
                        mood: "‚ú® Reflected",
                        avatar: "‚ú®"
                    },
                    'lose': {
                        messages: ["You broke the mirror!", "Reflection incomplete...", "My copy wasn't perfect!", "Time to re-calibrate reflection!"],
                        mood: "üí´ Fragmented",
                        avatar: "üí´"
                    },
                    'tie': {
                        messages: ["Perfect mirror match!", "Two reflections collide!", "We are the same!", "Mirror meets mirror!"],
                        mood: "üîÑ Synchronized",
                        avatar: "üîÑ"
                    }
                },
                'neutral': {
                    'start': {
                        messages: ["Ready for battle? Let's play!", "I'll analyze your patterns.", "May the best strategy win!", "Game on!"],
                        mood: "ü§ñ Ready",
                        avatar: "ü§ñ"
                    },
                    'win': {
                        messages: ["Good game! I predicted correctly.", "My analysis paid off!", "Strategy successful!", "Well played!"],
                        mood: "üòä Satisfied",
                        avatar: "üòä"
                    },
                    'lose': {
                        messages: ["Nice move! You got me there.", "Impressive strategy!", "I'll adapt for next time.", "You outplayed me!"],
                        mood: "ü§î Analyzing",
                        avatar: "ü§î"
                    },
                    'tie': {
                        messages: ["Great minds think alike!", "Even match!", "Balanced strategies!", "Perfect tie!"],
                        mood: "‚öñÔ∏è Balanced",
                        avatar: "‚öñÔ∏è"
                    }
                }
            };
            
            const personalityData = dialogues[personality] || dialogues['neutral'] || dialogues['berserker'];
            const eventData = personalityData[eventType] || personalityData['start'];
            
            return {
                message: eventData.messages[Math.floor(Math.random() * eventData.messages.length)],
                mood: eventData.mood,
                avatar: eventData.avatar
            };
        }
        
        function typeMessage(element, message) {
            element.textContent = '';
            let i = 0;
            const typingSpeed = 30; // ms per character
            
            function typeChar() {
                if (i < message.length) {
                    element.textContent += message.charAt(i);
                    i++;
                    setTimeout(typeChar, typingSpeed);
                }
            }
            
            typeChar();
        }
        
        // Advanced Analytics Functions
        function updateAlertRail(data, roundResult) {
            const alertContainer = document.getElementById('alert-feed');
            if (!alertContainer) return;

            const alerts = [];

            if (data && data.round) {
                alerts.push({ type: 'info', message: `Round ${data.round} complete` });
            }

            if (roundResult === 'human') {
                alerts.push({ type: 'positive', message: 'You claimed the last round ‚Äî keep the momentum!' });
            } else if (roundResult === 'robot') {
                alerts.push({ type: 'warning', message: 'The AI won the last exchange. Consider shifting patterns.' });
            } else if (roundResult === 'tie') {
                alerts.push({ type: 'info', message: 'Tie round ‚Äî a clean slate to pivot your strategy.' });
            }

            if (data && data.current_strategy) {
                const strategyLabels = {
                    'random': 'Random Baseline',
                    'frequency': 'Frequency Counter',
                    'markov': 'Markov Predictor',
                    'enhanced': 'Enhanced ML',
                    'lstm': 'LSTM Neural'
                };
                const label = strategyLabels[data.current_strategy] || data.current_strategy;
                alerts.push({ type: 'info', message: `AI strategy focus: ${label}` });
            }

            if (data && Array.isArray(data.human_history) && data.human_history.length) {
                const history = data.human_history;
                const tally = history.reduce((acc, move) => {
                    if (move) acc[move] = (acc[move] || 0) + 1;
                    return acc;
                }, {});

                const moves = Object.keys(tally);
                if (moves.length) {
                    const total = history.length;
                    const dominant = moves.reduce((a, b) => (tally[a] || 0) >= (tally[b] || 0) ? a : b);
                    const dominantPercent = ((tally[dominant] / total) * 100).toFixed(1);

                    if (dominantPercent >= 60) {
                        const label = dominant.charAt(0).toUpperCase() + dominant.slice(1);
                        alerts.push({ type: 'warning', message: `Pattern emerging: ${label} showing ${dominantPercent}% usage.` });
                        alerts.push({ type: 'action', message: 'Hop into Pattern View to disrupt the streak.' });
                    }

                    const recent = history.slice(-3);
                    if (recent.length === 3 && new Set(recent).size === 1) {
                        const streakMove = recent[0];
                        const label = streakMove.charAt(0).toUpperCase() + streakMove.slice(1);
                        alerts.push({ type: 'warning', message: `Three-in-a-row streak detected (${label}).` });
                    }
                }
            }

            if (!alerts.length) {
                alertContainer.innerHTML = "<div class='alert-chip muted'>Play a round to populate insights.</div>";
                return;
            }

            const badgeClass = (type) => {
                if (type === 'positive') return 'positive';
                if (type === 'warning') return 'warning';
                if (type === 'action') return 'action';
                return 'info';
            };

            alertContainer.innerHTML = alerts
                .map(alert => `<div class="alert-chip ${badgeClass(alert.type)}">${alert.message}</div>`)
                .join('');
        }

        function updateAnalyticsDashboard(data, insights) {
            if (isGameFrozen) return;
            if (!data.human_history || data.human_history.length === 0) return;

            // Check if game has ended based on round limit
            if (currentGameLimit && data.round >= currentGameLimit) {
                if (!isGameFrozen && !endgameSummaryShown) {
                    const summaryInsights = insights || deriveGameInsights(data);
                    freezeGame(data, summaryInsights);
                }
                return; // Don't update analytics if game has ended
            }

            insights = insights || deriveGameInsights(data);

            // Update the overview panel with the latest insights
            updateOverviewPanel(insights);

            const history = data.human_history;
            const totalMoves = history.length;

            const paperCount = history.filter(m => m === 'paper').length;
            const stoneCount = history.filter(m => m === 'stone').length;
            const scissorCount = history.filter(m => m === 'scissor').length;

            const paperPercent = totalMoves ? ((paperCount / totalMoves) * 100).toFixed(1) : '0.0';
            const stonePercent = totalMoves ? ((stoneCount / totalMoves) * 100).toFixed(1) : '0.0';
            const scissorPercent = totalMoves ? ((scissorCount / totalMoves) * 100).toFixed(1) : '0.0';

            document.getElementById('paper-fill').style.width = paperPercent + '%';
            document.getElementById('rock-fill').style.width = stonePercent + '%';
            document.getElementById('scissor-fill').style.width = scissorPercent + '%';

            document.getElementById('paper-percent').textContent = paperPercent + '%';
            document.getElementById('rock-percent').textContent = stonePercent + '%';
            document.getElementById('scissor-percent').textContent = scissorPercent + '%';

            const predictabilityScore = Math.max(parseFloat(paperPercent), parseFloat(stonePercent), parseFloat(scissorPercent)) || 0;
            document.getElementById('predictability-score').textContent = predictabilityScore.toFixed(1) + '%';

            let predictabilityStatus = 'Highly Unpredictable';
            if (predictabilityScore > 50) predictabilityStatus = 'Somewhat Predictable';
            if (predictabilityScore > 70) predictabilityStatus = 'Very Predictable';
            document.getElementById('predictability-status').textContent = predictabilityStatus;

            const winRate = insights.humanWinRate.toFixed(1);
            document.getElementById('win-rate-trend').textContent = winRate + '%';

            const p1 = totalMoves ? paperCount / totalMoves : 0;
            const p2 = totalMoves ? stoneCount / totalMoves : 0;
            const p3 = totalMoves ? scissorCount / totalMoves : 0;
            let entropy = 0;
            if (p1 > 0) entropy -= p1 * Math.log2(p1);
            if (p2 > 0) entropy -= p2 * Math.log2(p2);
            if (p3 > 0) entropy -= p3 * Math.log2(p3);
            const randomnessPercent = totalMoves ? ((entropy / Math.log2(3)) * 100).toFixed(1) : '0.0';
            document.getElementById('randomness-level').textContent = randomnessPercent + '%';

            let randomnessStatus = 'Low Randomness';
            if (randomnessPercent > 60) randomnessStatus = 'Medium Randomness';
            if (randomnessPercent > 80) randomnessStatus = 'High Randomness';
            document.getElementById('randomness-status').textContent = randomnessStatus;

            const swingCount = insights.winners.reduce((count, winner, idx, arr) => {
                if (idx === 0) return count;
                const prev = arr[idx - 1];
                if (winner === 'tie' || winner === 'unknown' || prev === 'tie' || prev === 'unknown') return count;
                return winner !== prev ? count + 1 : count;
            }, 0);
            document.getElementById('strategy-changes-count').textContent = swingCount;
            document.getElementById('changes-status').textContent = swingCount > 0 ? 'Momentum swings' : 'Stable';
        }
        
        function refreshAnalytics() {
            console.log('Refreshing analytics...');
            fetch('/history')
            .then(res => res.json())
            .then(data => {
                console.log('Analytics data received:', data);
                const insights = deriveGameInsights(data);
                updateOverviewPanel(insights);
                updateAnalyticsDashboard(data, insights);
                updateCharts(data);
            })
            .catch(err => console.log('Analytics refresh failed:', err));
        }
        
        function presentGameSummaryModal(payload) {
            if (endgameSummaryShown) return;
            endgameSummaryShown = true;

            const panel = document.getElementById('endgame-summary-panel');
            if (!panel) return;

            const insights = (payload && payload.human_history) ? deriveGameInsights(payload) : payload;
            const gameData = (payload && payload.human_history) ? payload : null;
            const roundsPlayed = gameData ? gameData.round : (payload?.round ?? 0);
            const matchLength = Number.isFinite(currentGameLimit) ? `${currentGameLimit} moves` : `${roundsPlayed} moves`;
            const humanWins = insights?.humanWins ?? 0;
            const robotWins = insights?.robotWins ?? 0;
            const winnerMessage = humanWins === robotWins
                ? 'ü§ù It ends in a draw ‚Äî closely matched strategies.'
                : humanWins > robotWins
                    ? 'üèÜ Winner: You outplayed the AI this round!'
                    : 'ü§ñ Winner: The AI claimed this match. Time to regroup!';

            panel.innerHTML = `
                <h2>üèÅ Game Complete</h2>
                <p class="summary-subtitle">Session summary after ${matchLength}</p>
                <div class="summary-winner">${winnerMessage}</div>
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-value">${(insights?.humanWinRate ?? 0).toFixed(1)}%</div>
                        <div class="summary-label">Your Win Rate</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-value">${(insights?.robotWinRate ?? 0).toFixed(1)}%</div>
                        <div class="summary-label">AI Win Rate</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-value">${insights?.longestHumanStreak || 0}</div>
                        <div class="summary-label">Best Streak</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-value">${insights?.mostCommonMove || '‚Äî'}</div>
                        <div class="summary-label">Favourite Move</div>
                    </div>
                </div>
                <div class="summary-section">
                    <h3>üéØ Strategy Highlights</h3>
                    <div class="summary-text">
                        <p><strong>Predictability:</strong> ${(insights?.moveVariance ?? 50).toFixed(1)}% ‚Äî ${(insights?.moveVariance ?? 50) > 60 ? 'High (easy to read)' : (insights?.moveVariance ?? 50) > 40 ? 'Moderate balance' : 'Low (unpredictable)'}</p>
                        <p><strong>Adaptation Rate:</strong> ${(insights?.patternChanges ?? 33).toFixed(1)}% ‚Äî ${(insights?.patternChanges ?? 33) > 60 ? 'Highly adaptive' : (insights?.patternChanges ?? 33) > 40 ? 'Moderately adaptive' : 'Stable patterns'}</p>
                        <p><strong>AI Difficulty:</strong> ${(gameData?.difficulty || currentDifficulty || 'unknown').toUpperCase()} (${(insights?.aiAccuracy ?? 50).toFixed(1)}% prediction accuracy)</p>
                    </div>
                </div>
                <div class="summary-section">
                    <h3>üí° Key Insight</h3>
                    <div class="summary-text">
                        ${insights?.recommendation || 'Keep exploring varied move sequences to stay ahead of the AI.'}
                    </div>
                </div>
                <div class="summary-actions">
                    <button class="btn outline" data-action="analytics">üìä Review Analytics</button>
                    <button class="btn outline" data-action="coach">ü§ñ Ask AI Coach</button>
                    <button class="btn primary" data-action="new-game">üîÑ New Game</button>
                </div>
            `;

            panel.classList.add('visible');
            panel.scrollIntoView({ behavior: 'smooth', block: 'center' });

            const analyticsBtn = panel.querySelector('[data-action="analytics"]');
            if (analyticsBtn) {
                analyticsBtn.addEventListener('click', () => {
                    const analyticsTab = document.querySelector('.mode-tab[data-mode="analytics"]');
                    analyticsTab?.click();
                    panel.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
            }

            const coachBtn = panel.querySelector('[data-action="coach"]');
            if (coachBtn) {
                coachBtn.addEventListener('click', () => {
                    window.open('/ai_coach_demo', '_blank');
                });
            }

            const newGameBtn = panel.querySelector('[data-action="new-game"]');
            if (newGameBtn) {
                newGameBtn.addEventListener('click', () => {
                    startNewGame();
                });
            }
        }

        function startNewGame() {
            isGameFrozen = false;
            const panel = document.getElementById('endgame-summary-panel');
            if (panel) {
                panel.classList.remove('visible');
                panel.innerHTML = '';
            }
            const calloutElement = document.getElementById('player-performance-callout');
            if (calloutElement) {
                calloutElement.classList.remove('visible');
                calloutElement.textContent = '';
            }
            endgameSummaryShown = false;
            resetGame();
        }
        
        function updateStatusDisplay() {
            // Update the game status to show current AI configuration
            const strategyText = {
                'balanced': 'Balanced Strategy',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const personalityText = {
                'neutral': 'Neutral Personality',
                'aggressive': 'Aggressive Personality',
                'defensive': 'Defensive Personality',
                'adaptive': 'Adaptive Personality',
                'chaotic': 'Chaotic Personality',
                'copycat': 'Copycat Personality'
            };
            
            console.log(`AI Config: ${currentDifficulty} + ${strategyText[currentStrategy]} + ${personalityText[currentPersonality]}`);
        }
        
        function applyPersonalityTheme(personality) {
            // Remove existing personality classes
            document.body.classList.remove('personality-aggressive', 'personality-defensive', 'personality-adaptive', 'personality-chaotic', 'personality-copycat');
            
            // Apply new personality theme
            if (personality !== 'neutral') {
                document.body.classList.add(`personality-${personality}`);
            }
            
            // Update UI elements based on personality
            const gameContainer = document.getElementById('app-root');
            if (gameContainer) {
                const themes = {
                    'neutral': { borderColor: 'rgba(79, 70, 229, 0.35)', backgroundColor: 'var(--bg-surface)' },
                    'aggressive': { borderColor: 'rgba(255, 68, 68, 0.6)', backgroundColor: 'rgba(64, 0, 0, 0.35)' },
                    'defensive': { borderColor: 'rgba(68, 68, 255, 0.6)', backgroundColor: 'rgba(0, 34, 68, 0.35)' },
                    'adaptive': { borderColor: 'rgba(153, 68, 255, 0.6)', backgroundColor: 'rgba(40, 0, 80, 0.35)' },
                    'chaotic': { borderColor: 'rgba(255, 136, 68, 0.6)', backgroundColor: 'rgba(68, 34, 0, 0.35)' },
                    'copycat': { borderColor: 'rgba(68, 255, 68, 0.6)', backgroundColor: 'rgba(0, 68, 34, 0.35)' }
                };
                
                const theme = themes[personality] || themes['neutral'];
                gameContainer.style.borderColor = theme.borderColor;
                gameContainer.style.backgroundColor = theme.backgroundColor;
            }
        }
        
        function exportAnalytics(format) {
            console.log('Exporting analytics in format:', format);
            fetch('/analytics/export?format=' + format)
            .then(res => res.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.' + format;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(err => {
                console.log('Export failed, creating manual export:', err);
                // Fallback: create manual JSON export
                const analyticsData = {
                    timestamp: new Date().toISOString(),
                    total_games: parseInt(document.getElementById('rounds').textContent) || 0,
                    predictability_score: document.getElementById('predictability-score').textContent,
                    win_rate: document.getElementById('win-rate-trend').textContent,
                    randomness_level: document.getElementById('randomness-level').textContent,
                    move_distribution: {
                        paper: document.getElementById('paper-percent').textContent,
                        rock: document.getElementById('rock-percent').textContent,
                        scissor: document.getElementById('scissor-percent').textContent
                    }
                };
                const dataStr = JSON.stringify(analyticsData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.json';
                a.click();
            });
        }
        
        function showDeveloperMetrics() {
            const metrics = {
                'Page Load Time': 'Fast',
                'API Response Time': 'Good',
                'JavaScript Errors': 'None',
                'Memory Usage': 'Normal',
                'Network Requests': 'Optimized'
            };
            
            let metricsHtml = '<h4>üîß Developer Metrics Console</h4>';
            for (const [key, value] of Object.entries(metrics)) {
                metricsHtml += `<p><strong>${key}:</strong> ${value}</p>`;
            }
            metricsHtml += '<p><em>All systems operational</em></p>';
            
            alert('Developer Metrics:\n\n' + Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join('\n'));
        }
        
        // Chart Functions
        function initializeCharts() {
            console.log('Initializing charts...');
            try {
                // Move Distribution Pie Chart
                const moveCtx = document.getElementById('moveDistributionChart');
                if (moveCtx) {
                    moveDistributionChart = new Chart(moveCtx, {
                        type: 'pie',
                        data: {
                            labels: ['Paper (P)', 'Rock (R)', 'Scissor (S)'],
                            datasets: [{
                                data: [0, 0, 0],
                                backgroundColor: ['#4CAF50', '#FF9800', '#F44336'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: '#f8fafc',
                                        font: { weight: 'bold', size: 13 }
                                    }
                                }
                            }
                        }
                    });

                    initializePredictionToggle();
                }
                
                // Win Rate Trend Line Chart
                const winCtx = document.getElementById('winRateTrendChart');
                if (winCtx) {
                    winRateTrendChart = new Chart(winCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Win Rate %',
                                data: [],
                                borderColor: '#1976D2',
                                backgroundColor: 'rgba(25, 118, 210, 0.1)',
                                fill: true,
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    ticks: {
                                        color: '#f8fafc',
                                        callback: function(value) {
                                            return value + '%';
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.12)'
                                    }
                                },
                                x: {
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.08)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Model Prediction Chart
                const modelCtx = document.getElementById('modelPredictionChart');
                if (modelCtx) {
                    modelPredictionChart = new Chart(modelCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Human Move',
                                    data: [],
                                    borderColor: '#FF6384',
                                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4
                                },
                                {
                                    label: 'Robot Move',
                                    data: [],
                                    borderColor: '#36A2EB',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4,
                                    hidden: true
                                },
                                {
                                    label: 'Frequency Prediction',
                                    data: [],
                                    borderColor: '#4BC0C0',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2,
                                    hidden: true
                                },
                                {
                                    label: 'Markov Prediction',
                                    data: [],
                                    borderColor: '#9966FF',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2,
                                    hidden: true
                                },
                                {
                                    label: 'Enhanced Prediction',
                                    data: [],
                                    borderColor: '#FF9F40',
                                    backgroundColor: 'rgba(255, 159, 64, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2,
                                    hidden: true
                                },
                                {
                                    label: 'LSTM Prediction',
                                    data: [],
                                    borderColor: '#6A5ACD',
                                    backgroundColor: 'rgba(106, 90, 205, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2,
                                    hidden: true
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: {
                                            size: 11
                                        },
                                        color: '#f8fafc'
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Move Number',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.08)'
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Moves',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    min: -0.5,
                                    max: 2.5,
                                    ticks: {
                                        stepSize: 1,
                                        color: '#f8fafc',
                                        callback: function(value) {
                                            if (value === 0) return 'S';
                                            if (value === 1) return 'R';
                                            if (value === 2) return 'P';
                                            return '';
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.12)'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Model Performance Metrics Chart
                const accuracyCtx = document.getElementById('modelAccuracyChart');
                if (accuracyCtx) {
                    modelAccuracyChart = new Chart(accuracyCtx, {
                        type: 'radar',
                        data: {
                            labels: ['Prediction Accuracy', 'Confidence Level', 'Consistency', 'Adaptability', 'Success Rate'],
                            datasets: [
                                {
                                    label: 'Random',
                                    data: [33, 33, 50, 25, 33],
                                    borderColor: 'rgba(255, 206, 86, 1)',
                                    backgroundColor: 'rgba(255, 206, 86, 0.2)',
                                    borderWidth: 2
                                },
                                {
                                    label: 'Frequency',
                                    data: [45, 60, 70, 40, 45],
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                    borderWidth: 2
                                },
                                {
                                    label: 'Markov',
                                    data: [55, 70, 65, 60, 55],
                                    borderColor: 'rgba(153, 102, 255, 1)',
                                    backgroundColor: 'rgba(153, 102, 255, 0.2)',
                                    borderWidth: 2
                                },
                                {
                                    label: 'Enhanced',
                                    data: [65, 80, 75, 80, 65],
                                    borderColor: 'rgba(255, 159, 64, 1)',
                                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                                    borderWidth: 2
                                },
                                {
                                    label: 'LSTM',
                                    data: [75, 85, 80, 90, 75],
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                    borderWidth: 2
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { 
                                    display: true,
                                    position: 'bottom',
                                    labels: {
                                        color: '#f8fafc',
                                        font: { weight: 'bold', size: 13 }
                                    }
                                }
                            },
                            scales: {
                                r: {
                                    beginAtZero: true,
                                    max: 100,
                                    pointLabels: {
                                        color: '#f8fafc',
                                        font: { weight: 'bold', size: 13 }
                                    },
                                    angleLines: {
                                        color: 'rgba(248,250,252,0.12)'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.12)'
                                    },
                                    ticks: {
                                        display: false
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Score Differential Chart
                const scoreDiffCtx = document.getElementById('scoreDifferentialChart');
                if (scoreDiffCtx) {
                    scoreDifferentialChart = new Chart(scoreDiffCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Score Differential',
                                data: [],
                                borderColor: '#4CAF50',
                                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                                fill: true,
                                tension: 0.3,
                                pointRadius: 3,
                                pointHoverRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Score Difference (You - AI)',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: function(context) {
                                            if (context.tick.value === 0) {
                                                return '#f8fafc';
                                            }
                                            return 'rgba(248,250,252,0.12)';
                                        }
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Round Number',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.08)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Confidence Trend Chart
                const confidenceCtx = document.getElementById('confidenceTrendChart');
                if (confidenceCtx) {
                    confidenceTrendChart = new Chart(confidenceCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Random',
                                    data: [],
                                    borderColor: 'rgba(255, 206, 86, 1)',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Frequency',
                                    data: [],
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Markov',
                                    data: [],
                                    borderColor: 'rgba(153, 102, 255, 1)',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Enhanced',
                                    data: [],
                                    borderColor: 'rgba(255, 159, 64, 1)',
                                    backgroundColor: 'rgba(255, 159, 64, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'LSTM',
                                    data: [],
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: { size: 10 },
                                        color: '#f8fafc'
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Move Number',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.08)'
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    max: 1,
                                    title: {
                                        display: true,
                                        text: 'Confidence',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.12)'
                                    }
                                }
                            }
                        }
                    });
                }
                
                console.log('Charts initialized successfully');
            } catch (error) {
                console.error('Error initializing charts:', error);
            }
        }
        
        let lastChartData = null;

        function updateCharts(data) {
            if (isGameFrozen) return;
            if (!data.human_history || data.human_history.length === 0) return;
            
            try {
                lastChartData = data;
                // Update Move Distribution Chart
                if (moveDistributionChart) {
                    const history = data.human_history;
                    const paperCount = history.filter(m => m === 'paper').length;
                    const stoneCount = history.filter(m => m === 'stone').length;
                    const scissorCount = history.filter(m => m === 'scissor').length;
                    const total = paperCount + stoneCount + scissorCount;
                    let paperPct = 0, stonePct = 0, scissorPct = 0;
                    if (total > 0) {
                        paperPct = ((paperCount / total) * 100).toFixed(1);
                        stonePct = ((stoneCount / total) * 100).toFixed(1);
                        scissorPct = ((scissorCount / total) * 100).toFixed(1);
                    }
                    // Update the chart
                    moveDistributionChart.data.datasets[0].data = [paperCount, stoneCount, scissorCount];
                    moveDistributionChart.update('none'); // No animation for performance
                    // Update the percentage display above the chart
                    const pctDiv = document.getElementById('moveDistributionPercentages');
                    if (pctDiv) {
                        pctDiv.innerHTML = `P: <b>${paperPct}%</b> &nbsp; | &nbsp; R: <b>${stonePct}%</b> &nbsp; | &nbsp; S: <b>${scissorPct}%</b>`;
                    }
                }
                
                // Update Win Rate Trend Chart
                if (winRateTrendChart && data.round > 0) {
                    const winRate = data.stats ? ((data.stats.human_win / data.round) * 100).toFixed(1) : 0;
                    
                    // Keep last 20 data points
                    if (winRateTrendChart.data.labels.length >= 20) {
                        winRateTrendChart.data.labels.shift();
                        winRateTrendChart.data.datasets[0].data.shift();
                    }
                    
                    winRateTrendChart.data.labels.push(`R${data.round}`);
                    winRateTrendChart.data.datasets[0].data.push(parseFloat(winRate));
                    winRateTrendChart.update('none');
                }
                
                // Update Score Differential Chart
                if (scoreDifferentialChart && data.stats) {
                    const scoreDiff = (data.stats.human_win || 0) - (data.stats.robot_win || 0);
                    
                    // Keep last 20 data points for performance
                    if (scoreDifferentialChart.data.labels.length >= 20) {
                        scoreDifferentialChart.data.labels.shift();
                        scoreDifferentialChart.data.datasets[0].data.shift();
                    }
                    
                    scoreDifferentialChart.data.labels.push(`R${data.round}`);
                    scoreDifferentialChart.data.datasets[0].data.push(scoreDiff);
                    
                    // Update line color based on if you're winning or losing
                    const isWinning = scoreDiff > 0;
                    scoreDifferentialChart.data.datasets[0].borderColor = isWinning ? '#4CAF50' : '#F44336';
                    scoreDifferentialChart.data.datasets[0].backgroundColor = isWinning ? 'rgba(76, 175, 80, 0.1)' : 'rgba(244, 67, 54, 0.1)';
                    
                    scoreDifferentialChart.update('none');
                }
                
                // Update Model Prediction Chart
                if (modelPredictionChart && data.human_history && data.robot_history) {
                    const moveToNumber = (move) => {
                        if (move === 'paper') return 2;
                        if (move === 'stone' || move === 'rock') return 1;
                        if (move === 'scissor') return 0;
                        return null;
                    };
                    
                    const humanData = data.human_history.map(moveToNumber);
                    const robotData = data.robot_history.map(moveToNumber);
                    
                    // Use real model predictions from backend
                    const modelPreds = data.model_predictions_history || {};
                    const pad = (arr) => {
                        const copy = Array.isArray(arr) ? arr.slice() : [];
                        while (copy.length < humanData.length) {
                            copy.push(null);
                        }
                        return copy;
                    };

                    const randomPreds = pad((modelPreds.random || []).map(moveToNumber));
                    const frequencyPreds = pad((modelPreds.frequency || []).map(moveToNumber));
                    const markovPreds = pad((modelPreds.markov || []).map(moveToNumber));
                    const enhancedPreds = pad((modelPreds.enhanced || []).map(moveToNumber));

                    const labels = Array.from({length: humanData.length}, (_, i) => i + 1);
                    let displayStart = 0;
                    const showAll = document.getElementById('prediction-range-toggle')?.checked;
                    if (!showAll && labels.length > 20) {
                        displayStart = labels.length - 20;
                    }
                    const displayLabels = labels.slice(displayStart);
                    const sliceData = (arr) => (displayStart > 0 ? arr.slice(displayStart) : arr);
                    
                    modelPredictionChart.data.labels = displayLabels;
                    const lstmPreds = pad((modelPreds.lstm || []).map(moveToNumber));
                    const datasets = [humanData, robotData, frequencyPreds, markovPreds, enhancedPreds, lstmPreds];
                    datasets.forEach((dataset, idx) => {
                        modelPredictionChart.data.datasets[idx].data = sliceData(dataset);
                    });

                    highlightMatches();
                    modelPredictionChart.update('none');
                }
                
                // Update Model Performance Metrics Chart
                if (modelAccuracyChart && data.accuracy) {
                    // Calculate real performance metrics for each model based on actual data
                    const models = ['random', 'frequency', 'markov', 'enhanced', 'lstm'];
                    const humanHistory = data.human_history || [];
                    const modelPreds = data.model_predictions_history || {};
                    const totalPredictions = data.total_predictions || {};
                    const correctPredictions = data.correct_predictions || {};
                    
                    models.forEach((model, index) => {
                        // 1. Prediction Accuracy - real accuracy from backend
                        const accuracy = data.accuracy[model] || 0;
                        
                        // 2. Confidence Level - based on model type and performance
                        let confidence = 33;
                        if (model === 'enhanced' && data.confidence) {
                            confidence = data.confidence * 100;
                        } else if (model === 'lstm') {
                            confidence = Math.min(90, 60 + (accuracy * 0.3));
                        } else if (model === 'markov') {
                            confidence = Math.min(80, 40 + (accuracy * 0.4));
                        } else if (model === 'frequency') {
                            confidence = Math.min(70, 30 + (accuracy * 0.5));
                        }
                        
                        // 3. Consistency - variance in recent predictions
                        let consistency = 50;
                        const predictions = modelPreds[model] || [];
                        if (predictions.length >= 10) {
                            const recent = predictions.slice(-10);
                            // Convert predictions to numbers for variance calculation
                            const numericRecent = recent.map(pred => {
                                if (typeof pred === 'string') {
                                    const move = pred.toLowerCase();
                                    if (move === 'paper') return 2;
                                    if (move === 'stone' || move === 'rock') return 1;
                                    if (move === 'scissor') return 0;
                                    return 1; // default to stone
                                }
                                return pred || 1;
                            }).filter(val => val !== null && val !== undefined);
                            
                            if (numericRecent.length > 0) {
                                const variance = calculateVariance(numericRecent);
                                consistency = Math.max(20, Math.min(100, 100 - (variance * 30)));
                            }
                        }
                        
                        // 4. Adaptability - based on model sophistication
                        const adaptability = {
                            'random': 10,
                            'frequency': 35,
                            'markov': 65,
                            'enhanced': 85,
                            'lstm': 95
                        }[model] || 33;
                        
                        // 5. Success Rate - win rate when this model is active
                        const successRate = accuracy;
                        
                        if (modelAccuracyChart.data.datasets[index]) {
                            modelAccuracyChart.data.datasets[index].data = [
                                Math.round(accuracy), 
                                Math.round(confidence), 
                                Math.round(consistency), 
                                adaptability, 
                                Math.round(successRate)
                            ];
                        }
                    });
                    modelAccuracyChart.update('none');
                }
                
                // Helper function to calculate variance
                function calculateVariance(values) {
                    if (values.length === 0) return 0;
                    const mean = values.reduce((a, b) => a + b, 0) / values.length;
                    const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
                    return Math.sqrt(variance);
                }
                
                // Update Confidence Trend Chart
                if (confidenceTrendChart && data.confidence !== undefined) {
                    const moveNum = data.round;
                    
                    // Simulate confidence values for different models (in real implementation, track actual confidence)
                    const confidenceValues = {
                        random: 0.33,
                        frequency: Math.min(0.8, 0.3 + (data.round * 0.02)),
                        markov: Math.min(0.85, 0.4 + (data.round * 0.015)),
                        enhanced: data.confidence || 0.5,
                        lstm: Math.min(0.9, 0.5 + (data.round * 0.01))
                    };
                    
                    if (confidenceTrendChart.data.labels.length > 20) {
                        // Keep only last 20 moves for performance
                        confidenceTrendChart.data.labels.shift();
                        confidenceTrendChart.data.datasets.forEach(dataset => dataset.data.shift());
                    }
                    
                    confidenceTrendChart.data.labels.push(moveNum);
                    confidenceTrendChart.data.datasets[0].data.push(confidenceValues.random);
                    confidenceTrendChart.data.datasets[1].data.push(confidenceValues.frequency);
                    confidenceTrendChart.data.datasets[2].data.push(confidenceValues.markov);
                    confidenceTrendChart.data.datasets[3].data.push(confidenceValues.enhanced);
                    confidenceTrendChart.data.datasets[4].data.push(confidenceValues.lstm);
                    confidenceTrendChart.update('none');
                }
                
                // Update Model Metrics Table
                updateModelMetrics(data);
                
                // Update Recommended Strategy
                updateRecommendedStrategy(data);
                
            } catch (error) {
                console.error('Error updating charts:', error);
            }
        }
        
        // Model Metrics Functions
        function updateModelMetrics(data) {
            const metricsContainer = document.getElementById('modelMetricsTable');
            if (!metricsContainer || !data.accuracy) return;
            
            const models = [
                { name: 'Random', key: 'random', color: '#FFCE56' },
                { name: 'Frequency', key: 'frequency', color: '#4BC0C0' },
                { name: 'Markov', key: 'markov', color: '#9966FF' },
                { name: 'Enhanced', key: 'enhanced', color: '#FF9F40' },
                { name: 'LSTM Neural', key: 'lstm', color: '#36A2EB' }
            ];
            
            metricsContainer.innerHTML = models.map(model => {
                const accuracy = data.accuracy[model.key] || 0;
                const correct = data.correct_predictions?.[model.key] || 0;
                const total = data.total_predictions?.[model.key] || 0;
                
                return `
                    <div style="background: linear-gradient(135deg, ${model.color}20, ${model.color}10); border-left: 4px solid ${model.color}; padding: 15px; border-radius: 8px;">
                        <h6 style="margin: 0 0 8px 0; color: #333; font-weight: bold;">${model.name} Strategy</h6>
                        <div style="font-size: 24px; font-weight: bold; color: ${model.color}; margin-bottom: 5px;">${accuracy.toFixed(1)}%</div>
                        <div style="color: #666; font-size: 12px;">
                            Predictions: ${correct}/${total}<br>
                            Status: ${accuracy > 60 ? 'üü¢ Excellent' : accuracy > 40 ? 'üü° Good' : 'üî¥ Needs Improvement'}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateRecommendedStrategy(data) {
            const recommendationEl = document.getElementById('recommendedStrategy');
            if (!recommendationEl || !data.accuracy) return;
            
            const accuracies = data.accuracy;
            const bestModel = Object.keys(accuracies).reduce((best, current) => 
                (accuracies[current] || 0) > (accuracies[best] || 0) ? current : best
            );
            
            const bestAccuracy = accuracies[bestModel] || 0;
            const modelNames = {
                'random': 'Random Strategy',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'enhanced': 'Enhanced ML',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const recommendation = bestAccuracy > 60 ? 
                `üèÜ ${modelNames[bestModel]} (${bestAccuracy.toFixed(1)}% accuracy)` :
                `üîÑ Continue analyzing patterns (Best: ${modelNames[bestModel]} at ${bestAccuracy.toFixed(1)}%)`;
                
            recommendationEl.innerHTML = `
                <div style="color: ${bestAccuracy > 60 ? '#4CAF50' : '#FF9800'};">
                    ${recommendation}
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    ${data.round < 10 ? 'Play more rounds for better analysis' : 'Pattern analysis complete'}
                </div>
            `;
        }
        
        // Tournament Management Functions
        function showTournamentDashboard() {
            fetch('/tournament')
            .then(res => res.json())
            .then(data => {
                updateTournamentDashboard(data);
                document.getElementById('tournamentModal').style.display = 'block';
            })
            .catch(err => console.error('Error fetching tournament data:', err));
        }
        
        function updateTournamentDashboard(data) {
            // Update leaderboard
            const leaderboardHtml = data.leaderboard.map((player, index) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: ${index < 3 ? '#f0f8ff' : '#f9f9f9'}; margin: 5px 0; border-radius: 5px;">
                    <div>
                        <span style="font-weight: bold; color: ${index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#666'};">
                            #${index + 1}
                        </span>
                        ${player.name}
                    </div>
                    <div style="text-align: right;">
                        <div style="font-weight: bold;">${Math.round(player.elo_rating)}</div>
                        <div style="font-size: 12px; color: #666;">${player.wins}W-${player.losses}L</div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('leaderboard').innerHTML = leaderboardHtml;
            
            // Update stats
            document.getElementById('totalPlayers').textContent = data.total_players;
            document.getElementById('totalMatches').textContent = data.total_matches;
        }
        
        function createTournamentPlayer() {
            const name = document.getElementById('newPlayerName').value.trim();
            if (!name) {
                alert('Please enter a player name');
                return;
            }
            
            fetch('/tournament/player', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({name: name})
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('newPlayerName').value = '';
                    showTournamentDashboard(); // Refresh dashboard
                    alert(`Player "${data.player.name}" created successfully!`);
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(err => {
                console.error('Error creating player:', err);
                alert('Error creating player');
            });
        }
        
        function createQuickMatch() {
            const player1 = document.getElementById('player1Name').value.trim();
            const player2 = document.getElementById('player2Name').value.trim();
            
            if (!player1 || !player2) {
                alert('Please enter both player names');
                return;
            }
            
            fetch('/tournament/match', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    player1_name: player1,
                    player2_name: player2
                })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    alert(`Match created between ${player1} and ${player2}!`);
                    document.getElementById('player1Name').value = '';
                    document.getElementById('player2Name').value = '';
                    // You could redirect to a match interface here
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(err => {
                console.error('Error creating match:', err);
                alert('Error creating match');
            });
        }
        
        // LLM Type Management
        function updateLLMType() {
            const selector = document.getElementById('llm-type-selector');
            const selectedLLM = selector.value;
            console.log(`Switching to LLM type: ${selectedLLM}`);
            
            // Update global LLM type
            window.currentLLMType = selectedLLM;
            
            // Show feedback
            const tipsList = document.getElementById('coaching-tips-list');
            tipsList.innerHTML = `<p style="color: #0066cc;">üîÑ Switched to ${selectedLLM.toUpperCase()} - Click "Get New Tips" to see the difference!</p>`;
        }
        
        // Coaching Functions
        function refreshCoachingTips() {
            console.log('Refreshing coaching tips...');
            const llmType = window.currentLLMType || document.getElementById('llm-type-selector').value || 'mock';
            
            // Show loading indicator based on LLM type
            const tipsContainer = document.getElementById('coaching-tips-list');
            let loadingMessage;
            switch(llmType) {
                case 'mock':
                    loadingMessage = 'üéØ MockLLM generating tips... (Fast)';
                    break;
                case 'trained':
                    loadingMessage = 'ü§ñ Our AI Model analyzing your gameplay... (~17ms)';
                    break;
                case 'real':
                    loadingMessage = 'üåê Real LLM thinking deeply... (This may take 30+ seconds)';
                    break;
                default:
                    loadingMessage = 'üîÑ Generating coaching tips...';
            }
            
            tipsContainer.innerHTML = `
                <div style="
                    display: flex; 
                    align-items: center; 
                    gap: 10px; 
                    padding: 15px; 
                    background: linear-gradient(90deg, #f0f9ff, #e0f2fe); 
                    border-left: 4px solid #0284c7;
                    border-radius: 6px;
                    color: #0369a1;
                    font-weight: 500;
                ">
                    <div class="loading-spinner" style="
                        width: 20px; 
                        height: 20px; 
                        border: 2px solid #0284c7; 
                        border-top: 2px solid transparent; 
                        border-radius: 50%; 
                        animation: spin 1s linear infinite;
                    "></div>
                    ${loadingMessage}
                </div>
            `;
            
            const startTime = Date.now();
            
            fetch('/coaching', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    llm_type: llmType
                })
            })
            .then(res => res.json())
            .then(data => {
                const responseTime = Date.now() - startTime;
                console.log(`Coaching data received in ${responseTime}ms:`, data);
                updateCoachingTips(data);
            })
            .catch(err => {
                console.log('Coaching tips unavailable:', err);
                document.getElementById('coaching-tips-list').innerHTML = 
                    '<p style="color: #666; font-style: italic;">Coaching tips will be available after more games.</p>';
            });
        }
        
        function updateCoachingTips(coachingData) {
            const tipsContainer = document.getElementById('coaching-tips-list');
            const experimentsContainer = document.getElementById('experiments-list');
            const insightsContainer = document.getElementById('insights-content');
            const insightsSummary = document.getElementById('insights-summary');
            
            // Determine which model was used
            const llmType = coachingData.llm_type || 'unknown';
            let modelBadge;
            switch(llmType) {
                case 'mock':
                    modelBadge = 'üéØ <span style="background: #e3f2fd; color: #1976d2; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">MockLLM</span>';
                    break;
                case 'trained':
                    modelBadge = 'ü§ñ <span style="background: #f3e5f5; color: #7b1fa2; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">Our AI</span>';
                    break;
                case 'real':
                    modelBadge = 'üåê <span style="background: #e8f5e8; color: #2e7d32; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">Real LLM</span>';
                    break;
                default:
                    modelBadge = '‚ùì <span style="background: #fafafa; color: #616161; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">Unknown</span>';
            }
            
            // Update tips with model indicator
            if (coachingData.coaching_tips && coachingData.coaching_tips.length > 0) {
                const modelHeader = `<div style="margin-bottom: 15px; padding: 8px 12px; background: rgba(0,0,0,0.05); border-radius: 6px; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                    Generated by: ${modelBadge}
                </div>`;
                
                const tipsHtml = coachingData.coaching_tips.map((tip, index) => 
                    `<div style="margin-bottom: 12px; padding: 10px; background: rgba(255,152,0,0.1); border-radius: 6px;">
                        <strong>${index + 1}.</strong> ${tip}
                    </div>`
                ).join('');
                tipsContainer.innerHTML = modelHeader + tipsHtml;
            } else {
                tipsContainer.innerHTML = '<p style="color: #666; font-style: italic;">Keep playing to get personalized tips!</p>';
            }
            
            // Update experiments
            if (coachingData.experiments && coachingData.experiments.length > 0) {
                const experimentsHtml = coachingData.experiments.map(exp => 
                    `<div style="margin-bottom: 15px; padding: 12px; background: rgba(76,175,80,0.1); border-radius: 6px;">
                        <strong style="color: #2e7d32;">${exp.name}</strong><br>
                        <small style="color: #388e3c;">${exp.description}</small><br>
                        <em style="font-size: 13px; color: #4caf50;">${exp.strategy}</em>
                    </div>`
                ).join('');
                experimentsContainer.innerHTML = experimentsHtml;
            } else {
                experimentsContainer.innerHTML = '<p style="color: #666; font-style: italic;">Experiment suggestions coming soon!</p>';
            }
            
            // Update insights (optional)
            if (coachingData.insights && Object.keys(coachingData.insights).length > 0) {
                const insights = coachingData.insights;
                let insightsHtml = '';
                
                if (insights.predictability !== undefined) {
                    const predPercent = (insights.predictability * 100).toFixed(1);
                    insightsHtml += `<p><strong>Predictability:</strong> ${predPercent}% - `;
                    insightsHtml += insights.predictability > 0.6 ? 'Too predictable!' : 'Good unpredictability';
                    insightsHtml += '</p>';
                }
                
                if (insights.pattern_type) {
                    insightsHtml += `<p><strong>Pattern Type:</strong> ${insights.pattern_type.replace('_', ' ')}</p>`;
                }
                
                if (insights.recent_performance) {
                    const winRate = (insights.recent_performance.win_rate * 100).toFixed(1);
                    insightsHtml += `<p><strong>Recent Win Rate:</strong> ${winRate}%</p>`;
                }
                
                if (insightsHtml) {
                    insightsContainer.innerHTML = insightsHtml;
                    insightsSummary.style.display = 'block';
                } else {
                    insightsSummary.style.display = 'none';
                }
            } else {
                insightsSummary.style.display = 'none';
            }
        }
        
        function setDifficulty() {
            currentDifficulty = document.getElementById('difficulty').value;
            console.log('Difficulty set to:', currentDifficulty);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        function setStrategy() {
            currentStrategy = document.getElementById('strategy').value;
            console.log('Strategy set to:', currentStrategy);
            updateStatusDisplay();
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        function setPersonality() {
            currentPersonality = document.getElementById('personality').value;
            console.log('Personality set to:', currentPersonality);
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            updateRobotConversation(currentPersonality, 'start');
        }
        
        function setGameLength() {
            const gameLength = document.getElementById('game-length').value;
            currentGameLimit = gameLength === 'infinite' ? null : parseInt(gameLength);
            console.log('Game length set to:', currentGameLimit);
            
            // Show notification only if called from dropdown change (not initial load)
            if (document.readyState === 'complete') {
                const notification = document.createElement('div');
                notification.className = 'game-notification';
                notification.innerHTML = currentGameLimit 
                    ? `üéØ Game limited to ${currentGameLimit} rounds`
                    : '‚ôæÔ∏è Game set to unlimited rounds';
                notification.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 10000;
                    background: var(--accent-color); color: white; padding: 15px 20px;
                    border-radius: 8px; font-weight: bold; animation: slideIn 0.3s ease;
                `;
                document.body.appendChild(notification);
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 2000);
            }
        }
        
        // DEBUG: Test function to manually trigger robot update
        function testRobotUpdate() {
            console.log('=== MANUAL TEST TRIGGERED ===');
            const diff = document.getElementById('difficulty').value;
            const strat = document.getElementById('strategy').value;
            const pers = document.getElementById('personality').value;
            
            console.log('Current dropdown values:', { diff, strat, pers });
            console.log('Current JS variables:', { currentDifficulty, currentStrategy, currentPersonality });
            
            // Update variables
            currentDifficulty = diff;
            currentStrategy = strat;
            currentPersonality = pers;
            
            console.log('Calling updateRobotCharacter...');
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        
        function resetGame() {
            fetch('/reset', {method: 'POST'})
            .then(res => res.json())
            .then(() => location.reload())
            .catch(error => {
                console.error('Reset error:', error);
                location.reload();
            });
        }
        
        // üéÆ ENHANCED REPLAY FUNCTIONS (New Feature #1)
        function saveCurrentReplay() {
            const name = prompt('Enter a name for this replay:', 'Game Session ' + new Date().toLocaleString());
            if (name) {
                const notes = prompt('Enter any notes (optional):', '');
                const formData = new FormData();
                formData.append('name', name);
                formData.append('notes', notes || '');
                
                fetch('/replay/save', {
                    method: 'POST',
                    body: formData
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        alert(`‚úÖ Replay saved successfully!\nSession ID: ${data.session_id}\nTotal rounds: ${data.total_rounds}`);
                    } else {
                        alert(`‚ùå Failed to save replay: ${data.message}`);
                    }
                })
                .catch(err => {
                    alert('‚ùå Error saving replay: ' + err.message);
                });
            }
        }
        
        // Disabled Tournament Message Function
        function showDisabledMessage(message) {
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.className = 'disabled-notification';
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        console.log('Main page script loaded successfully');
    </script>
</body>
</html>
